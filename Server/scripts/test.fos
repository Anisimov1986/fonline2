// Author: cvet
// For test reasons, can be exluded in any time
#include "_macros.fos"

#include "traveller.fos"
#include "serializator.fos"
#include "fix_boy_defines.fos"
#include "utils_for_array.fos"
#include "lexems_h.fos"
#include "mapdata_h.fos"
#include "utils_h.fos"

#define NAMES_FILE_NAME    "report.txt"

#define _FactionName		# (i)		("FACTION" +i+ "INFO")
//import bool AddAttackPlane( Critter& npc, uint priority, Critter& target ) from "npc_planes";
import uint GetAttackProtectionCount(Critter& critter) from "custom_data";
import int GetOffenceLevel(Critter& critter) from "critter_offence";
import void ClearOffenceLevel(Critter& critter) from "critter_offence";
import void SendQuestMessage(Critter& critter, uint questNameMsgNum, uint questTaskMsgNum) from "quest";
import void DropDrugEffects( Critter& cr ) from "drugs";
import void SaveCustomVal(Item& item, int ValueNum, int Value) from "custom_items";
import void SetDeterioration( Item& item, int deteriorationProcent , int repairPool) from "repair"; //Import
import void AddNewMessage( string text,int time, int showtimer, uint color) from "stocmessages";
import void AddAchievement(Critter& cr, uint achievement) from "achievements";
import bool ConsumedBlueprint(Critter& player, uint pid) from "blueprints";
import uint16 GetRandomTypeBlueprintPid(int8 type, uint8 level) from "blueprints";



void FindCarWithKey( Critter& cr, int pid, int , int )
{
	array<Item@> items;
	uint         count = 0;
    count = GetAllItems(0, items);
	for(uint i = 0; i < count; i++)
    {
        if (items[i].GetType()==ITEM_TYPE_CAR && items[i].LockerId==uint(pid))
        {
            if(items[i].Accessory == ACCESSORY_CRITTER)
				cr.Say(SAY_NETMSG, "Car on critter " + items[i].CritId);
			else if(items[i].Accessory == ACCESSORY_HEX)
			{
				cr.Say(SAY_NETMSG, "Car in map " + items[i].MapId);
			}
        }
    }
}

void FoundLocByOwner(Critter& player, int id, int, int)
{
	if (id==0)
        return;
    Location@[] locs;
    GetAllLocations( 0, locs );
	
	for (uint i = 0; i < locs.length(); i++)
	{
		
        if (id==GetRootMapData(locs[i],MAP_DATA_BASE_OWNER))
        {
            Map@ map = locs[i].GetMapByIndex(0);
            player.Say(SAY_NETMSG, "Location "+locs[i].Id+" Main map id "+map.Id);	
        }
	}

}



void patchbagckeck(Critter& player,int ,int,int)
{
    Critter@[] critters;
    GetAllNpc( 0, critters );
    for (uint i = 0; i < critters.length();i++)
    {
        Critter@ cr = critters[i];
        if (!valid(cr))
            continue;
        Location@ loc = GetLocationOf(cr); 
        if (valid(loc) && (loc.IsTown() || loc.GetProtoId()==LOCATION_Necropolis || loc.GetProtoId()==LOCATION_Cathedral))
            cr.ParamBase[BAG_CHECK]=1;
    }
}

void disablebagsinloc(Critter& cr,int ,int,int)
{
    Map@ map =  cr.GetMap();     
    if(!valid(map))
        return;
    Critter@[] critters;
    map.GetCritters( 0, FIND_ALL | FIND_ONLY_NPC , critters );
    for (uint i = 0; i < critters.length();i++)
    {    
        critters[i].SetBagRefreshTime((uint(-1)));
    }
}

void fixgarbage(Critter& cr,int ,int,int)
{
    Critter@[] critters;
    GetAllNpc( 0, critters );
    for (uint i = 0; i < critters.length();i++)
    {
        if (valid(critters[i]) && !ItemsIsSafe(critters[i]))
        {
            Critter@ cr = critters[i];
            Location@ loc =  GetLocationOf( cr );
            if (valid(loc) && (loc.IsTown() || loc.GetProtoId()==LOCATION_Necropolis || loc.GetProtoId()==LOCATION_Cathedral))
            {
                array<Item@> items;
                cr.GetItemsByType(ITEM_TYPE_WEAPON, items);
                {
                    for (uint z = 0; z < items.length(); z++)
                    {
                        if (z>0 && valid(items[z]))
                            DeleteItem(items[z]);
                    }
                }
            }
        }
    }
}

void fixdummybp(Critter& cr,int ,int,int)
{
    array<uint16> bugbp = { 10975, 10976, 10977, 10978};
    for (uint i = 0; i < bugbp.length();i++)
    {
        array<Item@> items;
        uint         count = 0;
        GetAllItems(bugbp[i], items);
        for (uint z = 0; z < items.length();z++)
        {
                if (valid(items[z]))
                {
                    Item@ item = items[z];
                    uint16 pid = GetRandomTypeBlueprintPid(item.Proto.Blueprint_Type, item.Proto.Blueprint_Level);
                    if(pid == 0)
                    {
                        Log("no blueprints for item type " + item.Proto.Blueprint_Type + ", level " + item.Proto.Blueprint_Level);
                        DeleteItem(item);
                    }
                    else
                    {
                        item.ChangeProto(pid);
                        item.SetScript("");
                        item.Update();
                    }
                }
        
        }
    }
}



void unreadbp(Critter& cr,int id,int,int)
{
    Critter@[] crs;
	GetAllPlayers(crs);
    ProtoItem@ proto = GetProtoItem(id); 
    if(proto.Type != ITEM_TYPE_BLUEPRINT)
        return;
    for (uint i = 0; i < crs.length();i++)
    {
        if (ConsumedBlueprint(crs[i], id))
        {
            UNSETFLAG(crs[i].ParamBase[proto.Blueprint_Param], (1 << proto.Blueprint_Id));
            crs[i].DropTimers();
            cr.Say(SAY_NETMSG, "Unread bp for cr "+crs[i].Id);	
        }
    }
}


void getmapdata(Critter& player, int index, int , int )
{
	Map@ map = player.GetMap();
	if (!valid(map))
		return;
	player.Say(SAY_NETMSG, "mapdata ("+index+") is "+map.GetData(index));	
}

void setmapdata(Critter& player, int index, int val, int )
{
	Map@ map = player.GetMap();
	if (!valid(map))
		return;
	map.SetData(index, val);
	player.Say(SAY_NETMSG, "mapdata ("+index+") set to "+map.GetData(index));	
}

void getnamebyid(Critter& player, int id, int , int )
{
	player.Say(SAY_NETMSG, ""+GetSafePlayerName(id));
}

void testchess(Critter& player, int , int , int )
{
	if (d_IsNotChess( player, null ))
		Log("All ok");
}

bool d_IsNotChess( Critter& player, Critter @ npc )
{
	if ((player.StatBase[ST_BONUS_LOOK]-player.Param[PE_SHARPSHOOTER]*6-player.Param[PE_IMPLANT_ACCURACY]*5-player.Param[PE_IMPLANT_MARKSMAN]*2)!=0)
		return false;
	if ((player.StatBase[ST_CRITICAL_CHANCE]-player.Param[TRAIT_FINESSE]*10-player.Param[PE_MORE_CRITICALS]*8-player.Param[PE_IMPLANT_MARKSMAN]*4)!=0)
		return false;
	if ((player.StatBase[ST_HEALING_RATE]-player.Param[TRAIT_FAST_METABOLISM]*10-player.Param[PE_IMPLANT_ENVIRONMENTAL]*10-player.Param[PE_FASTER_HEALING]*8)!=0)
		return false;
	return true;
}

void roll(Critter& player, int dice , int , int )
{
        string action = "";
        action = "rolls a "+Random(1,dice)+" on the 1d"+dice+" dice";
        VerboseAction( player, action );
}

void DeleteStart( Critter& cr,int , int, int)
{
    uint deleted=0;
	Map@[] maps;
    ::GetAllMaps( 0, maps );
    for( uint i = 0, j = maps.length(); i < j; i++ )
    {
        bool todelete=true;
		Map@   map = maps[ i ];
        if (map.GetProtoId()==415)
		{
			if (__FullSecond - uint(map.GetData(MAP_DATA_LASTENTERED))> REAL_DAY(30))
			{
                Item@[] items;
				uint n = map.GetItems(0, items);
				for (uint k=0; k < n;k++) 
				{
					Item@ item=items[k];
					if (valid(item))
					{
						if (item.GetType()==ITEM_TYPE_CONTAINER)
						{
							Item@[] itemsincontainer;
							if (item.GetItems(0, itemsincontainer)>0)
							{
								todelete=false;
								continue;
							}
						}
						else if (item.GetType()!=ITEM_TYPE_MISC)
						{
							todelete=false;
							continue;
						}
					}
				}
				if (!todelete)
					continue;
				Location@ loc = map.GetLocation();
				if (!valid(loc))
					continue;
				Log("Deleted Location "+loc.Id+" Owner "+GetRootMapData(map, MAP_DATA_TENT_OWNER));	
				DeleteLocation(loc.Id);
				deleted++;
			}
		}
    }
	cr.Say(SAY_NETMSG, "Deleted "+deleted+" locations.");	
}

void FixCrParam( Critter& cr,int players, int param, int value)
{
	Critter@[] crs;
	if (players==0)
		GetAllNpc( 0, crs );
	else
		GetAllPlayers(crs);
	for( uint i = 0, j = crs.length(); i < j; i++ )
    {
		if (valid(crs[i]))
		{
			if (crs[i].Param[param] != value)
            {
                cr.Say(SAY_NETMSG, "Crit Id "+crs[i].Id+"Had value "+crs[i].Param[param]);
                crs[i].ParamBase[param] = value;
            }            
		}
	}
}

void FindCrWithParam( Critter& cr,int players, int param, int value)
{
	Critter@[] crs;
	if (players==0)
		GetAllNpc( 0, crs );
	else
		GetAllPlayers(crs);
	for( uint i = 0, j = crs.length(); i < j; i++ )
    {
		if (valid(crs[i]) && crs[i].Param[param] == value)
		{
			cr.Say(SAY_NETMSG, "Id "+crs[i].Id);	
		}
	}
}

void FindGeckEnc( Critter& cr, int skip, int, int )
{
	Location@[] locs;
    GetAllLocations( 0, locs );
	for( uint i = 0, j = locs.length(); i < j; i++ )
    {
		if (valid(locs[i]) && locs[i].IsEncounter() && locs[i].GeckCount>0)
		{
			if (skip>0)
			{
				skip--;
				continue;
			}
			Map@ map = locs[i].GetMapByIndex(0);
			if (valid(map))
			{
				cr.Say(SAY_NETMSG, "mapId "+map.Id);
				cr.TransitToMap( map.Id, 0 );
				return;
			}
		}
	}
}

void LastTime( Critter& cr, int anydata , int , int )
{
	Map@ map = cr.GetMap();
	if (!valid(map))
		return;
	int time = GetRootMapData(map,anydata);
	if (time==0)
	{
		cr.Say(SAY_NETMSG, "wrong data");
		return;
	}
	if(__FullSecond - time > int(REAL_DAY(1)))
		cr.Say(SAY_NETMSG, "time more than " + (__FullSecond-time)/REAL_DAY(1) +" days");
	else if (__FullSecond - time > int(REAL_MINUTE(1)))
		cr.Say(SAY_NETMSG, "time more than " + (__FullSecond-time)/REAL_MINUTE(1) +" minutes");
	else
		cr.Say(SAY_NETMSG, "less than minute");
}

void RecolorThisLoc( Critter& cr, int color, int, int )
{
	if (color==0)
		return;
	Map@ map = cr.GetMap();
    if (!valid(map))
		return;
	Location@ loc = map.GetLocation();
	if (!valid(loc))
		return;
	loc.Color=color;
	loc.Update();
}

void noname( Critter& cr, int pid, int , int )
{
	if (FLAG(cr.ParamBase[CR_FLAGS1], CR_NO_NAME))
		UNSETFLAG(cr.ParamBase[CR_FLAGS1], CR_NO_NAME);
	else
		SETFLAG(cr.ParamBase[CR_FLAGS1], CR_NO_NAME);
}

void gm( Critter& cr, int pid, int , int )
{
	if (FLAG(cr.ParamBase[CR_FLAGS1], CR_GM))
		UNSETFLAG(cr.ParamBase[CR_FLAGS1], CR_GM);
	else
		SETFLAG(cr.ParamBase[CR_FLAGS1], CR_GM);
}

void InitDeleteQuestLocs( Critter& cr, int pid, int day, int )
{
	if (pid == 0 || day ==0)
		return;
	Location@[] locs;
    GetAllLocations( 0, locs );
    uint num=0;
	for( uint i = 0, j = locs.length(); i < j; i++ )
    {
		if (valid(locs[i]) && locs[i].GetProtoId()==pid)
		{
			CreateTimeEvent(__FullSecond+REAL_DAY(day),"quest@e_DeleteLocation",locs[i].Id,true);
			num++;
		}
    }
	Log("Created events for "+num+" locations");
}
/*
void DeleteKennyUnused( Critter& cr, int, int, int )
{
	Location@[] locs;
    GetAllLocations( 0, locs );
    uint num=0;
	for( uint i = 0, j = locs.length(); i < j; i++ )
    {
        if (valid(locs[ i ]) && locs[ i ].GetProtoId()==250)
		{
			string@ name = GetPlayerName(GetRootMapData(locs[ i ], MAP_DATA_TENT_OWNER));
			if (!valid(name))
			{
				DeleteLocation(locs[ i ].Id);
				num++;
			}
		}
    }
	Log("Deleted "+num+" unused Kenny locations");
}
*/
void DeleteAllLocsByProto( Critter& cr, int id, int, int )
{
	Location@[] locs;
    GetAllLocations( 0, locs );
    uint num=0;
	for( uint i = 0, j = locs.length(); i < j; i++ )
    {
        if (valid(locs[ i ]) && locs[ i ].GetProtoId()==id)
		{
				DeleteLocation(locs[ i ].Id);
				num++;
		}
    }
	Log("Deleted "+num+" locations");
}

void DeleteBrahmins( Critter& cr, int, int, int )
{
	Critter@[] npcs;
    GetAllNpc( 0, npcs );
	for( uint i = 0, j = npcs.length(); i < j; i++ )
    {
		if (valid(npcs[i]) && npcs[i].GetProtoId() == 10)
		{
			Map@ map = npcs[i].GetMap();
			if (valid(map) && map.GetLocation().GetProtoId()==250)
			{
				DeleteNpc(npcs[i]);
			}
			else if (!valid(map))
			{
				DeleteNpc(npcs[i]);
			}
		}
	}
}

void DeleteScorps( Critter& cr, int, int, int )
{
	Critter@[] npcs;
    GetAllNpc( 0, npcs );
	for( uint i = 0, j = npcs.length(); i < j; i++ )
    {
		if (valid(npcs[i]))
		{
			Map@ map = npcs[i].GetMap();
			if (valid(map) && map.GetLocation().GetProtoId()==250)
			{
				DeleteNpc(npcs[i]);
			}
		}
	}
}

void DeleteDeadOnStart( Critter& cr, int, int, int )
{
	Critter@[] npcs;
    GetAllNpc( 0, npcs );
	for( uint i = 0, j = npcs.length(); i < j; i++ )
    {
		if (valid(npcs[i]) && npcs[i].IsDead())
		{
			Map@ map = npcs[i].GetMap();
			if (valid(map) && map.GetProtoId()==415)
			{
				DeleteNpc(npcs[i]);
			}
		}
	}
}

void patchlexems( Critter& cr, int, int, int )
{
    Item@[] items;
    uint count = ::GetAllItems( 0, items );
    for( uint i = 0; i < count; i++ )
	{
		if(Present(items[i].GetProtoId(),Pids_Signed) && items[i].Info==2)
		{
			if (GetLexem(items[i],"$statsname")=="Regular" && IsLexem(items[i],"$craftername"))
			{
				string color="|"+COLOR_TEXT;
				if (IsLexem(items[i],"$statsname2"))
					UnsetLexem(items[i],"$statsname2");
				items[i].SetLexems( "$statsname" + color  + "$craftername" +GetLexem(items[i], "$craftername"));
				items[i].Update();
			}
		}
	}
}

void itemnao( Critter& cr, int id, int , int )
{
	Item@[] items;
	Item@ item = GetItem(id);
	if (valid(item))
	{
		items.insertLast(item);
		MoveItems(items, cr);
	}

}
	
	
void finditem( Critter& cr, int pid, int num, int )
{
	array<Item@> items;
	uint         count = 0;
    count = GetAllItems(pid, items);
	for(uint i = 0; i < count; i++)
    {
		if (items[i].GetCount()>=uint(num))
		{
			if(items[i].Accessory == ACCESSORY_CRITTER)
				cr.Say(SAY_NETMSG, "item on critter " + items[i].CritId);
			else if(items[i].Accessory == ACCESSORY_CONTAINER)
			{
				Item@ cont = GetItem(items[i].ContainerId);
				cr.Say(SAY_NETMSG, "item in container in map " + cont.MapId);
			}
			else if(items[i].Accessory == ACCESSORY_HEX)
			{
				cr.Say(SAY_NETMSG, "item on ground in map " + items[i].MapId);
			}
		}
	}
	items.resize(0);
}

void finditemgeck( Critter& cr, int , int , int )
{
	array<Item@> items;
	uint         count = 0;
    count = GetAllItems(0, items);
	for(uint i = 0; i < count; i++)
    {
		if( !FLAG( items[i].Flags, ITEM_GECK ) )
			continue;
		if(items[i].Accessory == ACCESSORY_CRITTER)
            cr.Say(SAY_NETMSG, "item on critter " + items[i].CritId);
        else if(items[i].Accessory == ACCESSORY_CONTAINER)
        {
            Item@ cont = GetItem(items[i].ContainerId);
            cr.Say(SAY_NETMSG, "item in container in map " + cont.MapId);
        }
		else if(items[i].Accessory == ACCESSORY_HEX)
		{
			cr.Say(SAY_NETMSG, "item on ground in map " + items[i].MapId);
		}
	}
	items.resize(0);
}


void finditembytype( Critter& cr, int type, int excludeground, int )
{
	array<Item@> items;
	uint         count = 0;
    count = GetAllItems(0, items);
	for(uint i = 0; i < count; i++)
    {
		if( items[i].GetType()!=type)
			continue;
		if(items[i].Accessory == ACCESSORY_CRITTER)
            cr.Say(SAY_NETMSG, "item "+items[i].Id+" on critter " + items[i].CritId);
        else if(items[i].Accessory == ACCESSORY_CONTAINER)
        {
            Item@ cont = GetItem(items[i].ContainerId);
            cr.Say(SAY_NETMSG, "item "+items[i].Id+" in container in map " + cont.MapId);
        }
		else if(excludeground==0 && items[i].Accessory == ACCESSORY_HEX)
		{
			cr.Say(SAY_NETMSG, "item "+items[i].Id+" on ground in map " + items[i].MapId);
		}
	}
	items.resize(0);
}

void showscreenpanel( Critter& cr, int, int, int )
{
	cr.RunClientScript("client_main@ShowAdminPanel", 0, 0, 0, null, null);
}

void setlexem( Critter& cr, int, int, int )
{
	SetLexem(cr, "$faction", "SoT");
}

void dellexem( Critter& cr, int, int, int )
{
	 UnsetLexem(cr, "$faction");
}


void testdlg( Critter& cr, int, int, int )
{
	cr.SayMsg( SAY_DIALOG, TEXTMSG_DLG, ( DLGSTR( 10, 1 ) ) );
}
 
void deletefaction( Critter& cr, int id, int, int )
{
	if(!IsAnyData("FACTIONS"))
		return;
	if (IsAnyData("FACTION"+id+"MEMBERS"))
		EraseAnyData( "FACTION"+id+"MEMBERS" );
	if (IsAnyData("FACTION"+id+"INFO"))
		EraseAnyData( "FACTION"+id+"INFO" );
}
 
void testnewfaction( Critter& cr, int, int, int )
{
	if (!Checkname(cr,"Testfaction"))
		return;
	Serializator newfaction;
	int []FactionNum(1);
	GetAnyData("FACTIONS", FactionNum);
	FactionNum[0]++;
	SetAnyData("FACTIONS", FactionNum);
	newfaction.Set("Testfaction");
	newfaction.Save("FACTION"+FactionNum[0]+"INFO");
	FactionNum.resize(0);
	newfaction.Clear();
}

void ChangeFUCKname( Critter& cr, int, int, int )
{
	Serializator newfaction;
	newfaction.Set("The Fists").Save(_FactionName(10));
}

void ChangeFUCKname2( Critter& cr, int, int, int )
{
	Serializator newfaction;
	newfaction.Set("New Order").Save(_FactionName(39));
}


void showfactions( Critter& cr, int, int, int )
{
	if(!IsAnyData("FACTIONS"))
		return;
	Serializator factioninfo;
	int []FactionNum(1);
	GetAnyData("FACTIONS", FactionNum); 
	string Name;
	for (int i = 0; i <= FactionNum[0]; i++)
	{
		if(factioninfo.Load("FACTION"+i+"INFO"))
		{
			factioninfo.Get(Name);	
			cr.Say(SAY_NETMSG, i+" " + Name);	
		}

	}
}

bool Checkname(Critter& cr, string nameofnewfaction)
{
	if(!IsAnyData("FACTIONS"))
		return false;
	Serializator factioninfo;
	int []FactionNum(1);
	GetAnyData("FACTIONS", FactionNum); 
	string Name;
	for (int i = 0; i <= FactionNum[0]; i++)
	{
		if(factioninfo.Load("FACTION"+i+"INFO"))
		{
			factioninfo.Get(Name);	
			if (strlwr(Name)==strlwr(nameofnewfaction))
			{
				cr.Say(SAY_NETMSG, "Faction with same name already exists");
				return false;				
			}
		}

	}
	return true;
}



void initserial( Critter& cr, int, int, int )
{
	Serializator factioninfo;
	if(!factioninfo.Load("FACTION1INFO"))
		return;
string Name;
factioninfo.Get(Name);
Log(""+Name);
}

/*

void testserial( Critter& cr, int, int, int )
{
	if(!serializator.Load(_GetKey))
				return;
	string name;
	for i
	serializator.Get(Loaded2);
	serializator.Get(LoadedItemsCritter);
	
	Log(""+LoadedItemsCritter);
	Log(""+Loaded2);
	//int []Array();
	//GetAnyData(_GetKey,Array);
	//Log(""+Array.length);
}
*/


void DeleteEnc( Critter& cr, int, int, int )
{

	Location@[] locs;
    GetAllLocations( 0, locs );
    for( uint i = 0, j = locs.length(); i < j; i++ )
    {
        Location@   loc = locs[ i ];
        if (loc.AutoGarbage==true)
		{
			DeleteLocation(loc.Id);
		}	
    }
}
void DeleteLostNpc( Critter& cr, int, int, int )
{
	int count=0;
	Critter@[] npcs;
    GetAllNpc( 0, npcs );
	for( uint i = 0, j = npcs.length(); i < j; i++ )
    {
		if (npcs[i].GetMapId()==0 && npcs[i].GetProtoId()!=546)
		{
			count++;
			Log(""+npcs[i].GetProtoId ());
			DeleteNpc(npcs[i]);
		}
	}
	cr.Say( SAY_NETMSG, "Deleted="+count );
}

void DeleteRandomNpc( Critter& cr, int num, int, int )
{
	int count=0;
	Critter@[] npcs;
    GetAllNpc( 0, npcs );
	for( uint i = 0, j = npcs.length(); i < j; i++ )
    {
		if (npcs[i].GetProtoId()==num)// && npcs[i].GetProtoId()<=20)
		{
			count++;
			//Log(""+npcs[i].GetProtoId());
			DeleteNpc(npcs[i]);
		}
	}
	cr.Say( SAY_NETMSG, "Deleted="+count );
}

void RandomNpc( Critter& cr, int num, int, int )
{
	int count=0;
	Critter@[] npcs;
    GetAllNpc( 0, npcs );
	for( uint i = 0, j = npcs.length(); i < j; i++ )
    {
		if (npcs[i].GetProtoId()==num)// && npcs[i].GetProtoId()<=20)
		{
			Log("Pid"+npcs[i].Id);
		}
	}

}

void ShowKillExp( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_LIFE | FIND_ONLY_NPC , critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        if(critters[ i ].Stat[ST_KILL_EXPERIENCE] != 0)
			critters[ i ].Say(SAY_NORM_ON_HEAD, "Exp="+(critters[ i ].Stat[ST_KILL_EXPERIENCE]));
    }
}
void _RobotInit( Critter& turret, bool firstTime )
{
    turret.SetEvent( CRITTER_EVENT_SHOW_CRITTER, "_RobotShowCritter" );
    turret.ModeBase[ MODE_UNLIMITED_AMMO ] = 1;
}

void _RobotShowCritter( Critter& turret, Critter& cr )
{
    if( cr.IsPlayer() )
    {
		turret.AddEnemyInStack( cr.Id );
        AddAttackPlane( turret, 0, cr );
    }
}


void testlock( Critter& cr, int, int, int )
{
Log("1"+(_CritFingersDoorId( cr.Id )));
Log("2"+(_CritEyesDoorId( cr.Id )));
}



void unsafe_RefreshVisible(Critter& player, int  , int , int , string@  , int[]@ )
{
if (valid(player))
	player.RefreshVisible();
}

void refresh( Critter& cr, int, int, int )
{
cr.RefreshVisible();
}

void regenmap( Critter& cr, int, int, int )
{
	Map@ map = cr.GetMap();
	Critter@[] critters;
	map.GetCritters( 0, FIND_LIFE | FIND_ONLY_NPC , critters );
	for( uint i = 0, j = critters.length(); i < j; i++ )
	{
		critters[ i ].MoveRandom();
	}
}

void unsafe_changemod(Critter& player, int mod , int , int , string@ message , int[]@ )
{
	player.ModeBase[ MODE_DEFAULT_COMBAT ] = mod;
}

uint logevent=0;

void startlogging( Critter& player, int time, int , int  )
{
	if (logevent!=0)
	{
		EraseTimeEvent( logevent );
		logevent=0;
	}
	logevent = CreateTimeEvent( __FullSecond + REAL_SECOND(time), "_showonline", REAL_SECOND(time) , false );
}
void stoplogging( Critter& player, int , int , int  )
{
	EraseTimeEvent( logevent );
	logevent=0;
}

uint _showonline( uint[] @ values )
{
	Log("running");
	Critter@[] players;
	GetAllPlayers(players);
	file f;
    f.open( "C:/wwwroot/fonline2.com/test10.html", "w" );
	string line;
	int lineNumber;
	file z;
	f.writeString("<body bgcolor=#000000 style=color:#FFFFFF></body><div align=center><font color=#FFFFFF><TABLE BORDER><TR><TD>ID</TD><TD>NAME</TD><TD>LEVEL</TD><TD>CONDITION</TD><TD>POSITION</TD></TR>");
	{
		for (uint i=0; i<players.length() ; i++)
		{
			uint id=players[i].Id;
			string[] condtmp={"None","LIFE","KO","DEAD","OFF"};
			Map@ map = players[i].GetMap();
			string cond;
			if (_CritIsOffline(players[i]))
				cond=condtmp[players[i].Cond]+" (off)";
			else 
				cond=condtmp[players[i].Cond];
			uint mapid;
			string mapname;
			string@[]@ elements;
			if (valid (map))
			{
				z.open( "text/engl/FOGM.MSG", "r" );
				mapid = (map.GetProtoId()+1)*10;
				mapname = ""+mapid;
				lineNumber = 0;
				while(z.readLine(line) > 0)
				{
					lineNumber++;
					if (mapname==substring(line, 1, mapname.length()))
					{
						@elements = splitEx(line, "}{}{");
						@elements = splitEx(elements[1], "}");
						mapname=elements[0];
						break;
					}
						
				}
				z.close();
			}
			else 
			{
				mapname = players[i].WorldX+","+players[i].WorldY;
			}
			f.writeString("<TR><TD>"+ id +"</TD><TD>"+ GetPlayerName(players[i].Id)+ "</TD><TD>"+players[i].Param[ST_LEVEL]+"</TD><TD>"+cond+ "</TD><TD>" +mapname+ "</TD></TR>");
		}
	}
	f.writeString("</TABLE>\nTotal players "+players.length());
	f.writeString("<br>Total npc "+GetAllNpc( 0,  null  ))+"</font></div>";
	players.resize(0);
	f.close();
	return values[0];
}

void testdet( Critter& player, int deteriorationProcent , int repairPool , int  )
{
	Item@ item = player.GetItem( 0, SLOT_HAND1 );
	if (!valid(item))
		return;
	SetDeterioration( item, deteriorationProcent , repairPool);
}
import void StatsGeneration(string player, Item& item, bool crafted) from "custom_items";
void test5( Critter& player, int  , int  , int  )
{
	Item@ item = player.GetItem( 0, SLOT_HAND1 );
	if (!valid(item))
		return;

	StatsGeneration("Admin", item, true);
}

void testval( Critter& player, int ValueNum , int Value , int  )
{
Item@ item = player.GetItem( 0, SLOT_HAND1 );
if (!valid(item))return;
SaveCustomVal(item, ValueNum, Value);
}


void d_DropDrugEffects( Critter& player , Critter@ terminal)
{
player.Say( SAY_NETMSG, "Drugs dropped." );
DropDrugEffects( player );
}


void unsafe_pvpteam(Critter& player, int team , int , int , string@ message , int[]@ )
{
player.ParamBase[PVPTEAM]=team;
}



void testonline( Critter& player, int , int , int  )
{
	Critter@[] players;
	GetAllPlayers(players);
	player.Say(SAY_NETMSG, "Players online: " + players.length());	
	for (uint i=0; i<players.length() ; i++)
	{
		if(valid(players[i]) && _CritIsOnline(players[i]))
			player.Say(SAY_NETMSG, "Player: " + GetPlayerName(players[i].Id));	
		else if (valid(players[i]) && _CritIsOffline(players[i]))
			player.Say(SAY_NETMSG, "Player: " + GetPlayerName(players[i].Id) + " Offline");	
	}
	players.resize(0);
}

void servermessage(Critter& player, int , int , int , string@ message , int[]@ )
{
	Critter@[] players;
	GetAllPlayers(players);
	for (uint i=0; i<players.length() ; i++)
	{
		if(valid(players[i]) && _CritIsOnline(players[i]))
			players[i].RunClientScript("client_screen_messages@ShowServerMessage", 0, 0, 0, message, null);
	}
	players.resize(0);
}
	
void newservermessage(Critter& player, int , int , int , string@ message , int[]@ )
{
	AddNewMessage(message,REAL_SECOND(30),0,COLOR_WHITE);
}
			
void testpc(Critter& player, int , int , int , string@ , int[]@ )
{
	Map@ map = player.GetMap();
	if (valid(map) && map.GetProtoId()!=MAP_HG_Event)
	{
		RunDialog (player, 1000, 1, 1, true);
		AddAchievement(player,PE_ACHIEV_TESTER);
	}
}

void testArray( Critter& cr, int , int , int  )
{
	uint[] arr;
	arr.resize(0);
	arr.insertLast(1);
	arr.insertLast(2);
	cr.Say(SAY_NORM_ON_HEAD, "Array length: "+arr.length());
}

void getmaptime( Critter& cr, int , int , int  )
{
Map@ map = cr.GetMap();
if (valid(map))cr.Say(SAY_NETMSG, "Maptime in minutes"+map.GetTime());
}

void setmaptime( Critter& cr, int time, int , int  )
{
Map@ map = cr.GetMap();
if (valid(map))map.SetTime(time);
}

void timeoutReset(Critter& cr, int, int, int ) 
{
cr.TimeoutBase[TO_SK_FIRST_AID]=__FullSecond;
cr.TimeoutBase[TO_SK_DOCTOR]=__FullSecond;
cr.TimeoutBase[TO_SK_REPAIR]=__FullSecond;
cr.TimeoutBase[TO_SK_SCIENCE]=__FullSecond;
cr.TimeoutBase[TO_SK_LOCKPICK]=__FullSecond;
cr.TimeoutBase[TO_SK_STEAL]=__FullSecond;
cr.TimeoutBase[TO_JAIL]=__FullSecond;
cr.KarmaBase[ KARMA_CHILDKILLER ] = 0;
}

void testfov( Critter& cr, int p0, int p1, int p2 )
{
Critter@ player = GetCritter( p0 );
if(valid(player))
	{
	player.ParamBase[ST_BONUS_LOOK]=p1;
	}   
}
void testdiv( Critter& cr, int p0, int p1, int p2 )
{
if(valid(cr))
	{
    cr.Say(SAY_NETMSG, "!AP!"+3/2);
	cr.Say(SAY_NETMSG, "!AP!"+4/2);
	cr.Say(SAY_NETMSG, "!AP!"+5/2);
	}   
}


void setinvis( Critter& cr, int p0, int p1, int p2 )
{
Critter@ player = GetCritter( p0 );
if(valid(player))
	{
	player.ParamBase[INVIS_LEVEL]=p1;
	player.Say( SAY_NETMSG, "Invis level="+player.ParamBase[INVIS_LEVEL] );
	}   
}
void setvis( Critter& cr, int p0, int p1, int p2 )
{
Critter@ player = GetCritter( p0 );
if(valid(player))
	{
	player.ParamBase[VISION_LEVEL]=p1;
	player.Say( SAY_NETMSG, "VISION level="+player.ParamBase[VISION_LEVEL] );
	}   
}

/*
void unsafe_debuginfo (Critter& player, int mapid, int x, int y, string@ message, int[]@ param4)
{
int pad = 8;     // ~ignore_ 8 cимволов
if( int( message.length() ) <= pad )return;
if(message.length() > 100)return;
string description = substring( message, pad, message.length() - pad );
description=mapid+" "+x+" "+y+" "+description;
file f;
    if( f.open( "debug/"+NAMES_FILE_NAME, "a" ) == 0 )
	{
	f.writeString( strlwr( description ) + "\r\n" );
	}
}
*/

void testbutton ( Critter& cr, int p0, int p1, int p2 )
{
cr.ShowScreen(SCREEN_DIALOGBOX, 2, "answer_LOCKPICK");
cr.Say(SAY_DIALOGBOX_TEXT, "Выберите действие");
cr.Say(SAY_DIALOGBOX_BUTTON(0),"постучать");
cr.Say(SAY_DIALOGBOX_BUTTON(1),"выбить");
cr.Say(SAY_DIALOGBOX_BUTTON(2),"начать взлом");
}

void answer_LOCKPICK(Critter& player, uint answerI, string& answerS)
{
    if(answerI==0)Log("1");
	if(answerI==1)Log("2");
	if(answerI==2)Log("3");
}


void movescr ( Critter& cr, int p0, int p1, int p2 )
{
cr.RunClientScript("_MoveCamera", cr.Id, 33, 33, null, null);
}

void isknown( Critter& cr, int p0, int p1, int p2 )
{
 if (cr.IsKnownLoc(true, p0))cr.Say( SAY_NETMSG, "Known" );   
 
}


void test( Critter& cr, int p0, int p1, int p2 )
{
    Map@ map = cr.GetMap();
    if( not valid( map ) )
        return;
    Item@ car = map.AddItem( p0, p1, PID_HUMMER, 1 );
    // if(not valid(car)) return;
    car.Update();
}

void test1( Critter& cr, int p0, int p1, int p2 )
{
    cr.Say( SAY_NORM, "русские буквы АБВгДееейёёёё!" );
}

class Example
{
    int    a;
    int8   b;
    uint16 c;
    uint64[] arr;
    string str;
}

#include "serializator.fos"
void test2( Critter& cr, int p0, int p1, int p2 )
{
    Example e;
    e.a = -100;
    e.b = 123;
    e.c = 60000;
    e.str = "Example!";
    e.arr.resize( 5000 );

    for( uint i = 0; i < 10; i++ )
    {
        Serializator save;
        save.Set( e.arr ).Set( e.a ).Set( e.b ).Set( e.c ).Set( e.str ).Save( "Example_" + i );
    }

    cr.Say( SAY_NETMSG, "0<" + e.str + "," + e.a + "," + e.b + "," + e.c + ">" );
}

void test3( Critter& cr, int p0, int p1, int p2 )
{
    Example e;
    for( uint i = 0; i < 10; i++ )
    {
        Serializator load;
        if( load.Load( "Example_" + i ) )
            load.Get( e.arr ).Get( e.a ).Get( e.b ).Get( e.c ).Get( e.str );
    }


    cr.Say( SAY_NETMSG, "1<" + e.str + "," + e.a + "," + e.b + "," + e.c + ">" );
}

void zero( Critter& cr, int p0, int p1, int p2 )
{
//	float timeout = 2.0f;
//	float factor = 0.5f;
    float t = 1.0f / 0.9f;
    cr.Say( SAY_NETMSG, "!!!!!!!!!!!!!!" );
}

void test4( Critter& cr, int p0, int p1, int p2 )
{
    uint16 year = 0;
    uint16 month = 0;
    uint16 day_of_week = 0;
    uint16 day = 0;
    uint16 hour = 0;
    uint16 minute = 0;
    uint16 second = 0;
    GetGameTime( __FullSecond, year, month, day, day_of_week, hour, minute, second );
    uint   fm = GetFullSecond( year, month, day, hour, minute, second );

    Log( "Real: " + "FullSecond " + __FullSecond + " Year " + __Year + " Month " + __Month + " Day " + __Day + " Hour " + __Hour + " Minute " + __Minute + " Second " + __Second );
    Log( "Calc: " + "FullSecond " + fm + " Year " + year + " Month " + month + " Day " + day + " Hour " + hour + " Minute " + minute + " Second " + second + " DayOfWeek " + day_of_week );
}

/*
   void init(Critter@ npc, bool firstTime)
   {
        if(firstTime) npc.AddItem(PID_ADVANCED_POWER_ARMOR_MK2,1);
        npc.Wait(20000);
   }

   void idle(Critter@ npc)
   {
   //	TestMove(npc);
        TestObjMove(npc);
   //	TestVars(npc);
   }

   void TestMove(Critter@ npc)
   {
        _CritAnimateUse(npc);

        if(npc.HexX==260 && npc.HexY==209) return;
        npc.AddWalkPlane(260,209,3,false,0);
   }

   void TestObjMove(Critter@ npc)
   {
        npc.Say(SAY_NORM_ON_HEAD,"Эээх мой броник");

        Item@ armor=_CritGetItemArmor(npc);
        if(@armor==null)
        {
                @armor=_CritGetItem(npc,PID_ADVANCED_POWER_ARMOR_MK2);
                if(@armor==null)
                {
                        npc.Say(SAY_NORM_ON_HEAD,"Украли броник");
                        return;
                }

                _CritMoveItem(npc,armor,SLOT_ARMOR);
        }
        else
        {
                _CritMoveItem(npc,armor,SLOT_INV);
        }

        npc.Wait(10000);
   }

   void TestVars(Critter@ npc)
   {
        GameVar@ var=GetGlobalVar(GVAR_game_state);
        if(@var==null)
        {
                npc.Say(SAY_NORM_ON_HEAD,"Not found");
                return;
        }

        int v=var.GetValue();

        npc.Say(SAY_NORM_ON_HEAD,"var="+v);

        var=Random(0,5);

        npc.Wait(5000);
   }

 */

void answer_Generic( Critter& player, uint answerI, string& answerS )
{
    player.Say( SAY_NETMSG, "Answer integer<" + answerI + ">, string<" + answerS + ">." );
}

void elevator( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_ELEVATOR, ELEVATOR_BOS_1234( p0 ), "answer_Generic" );
}

void dlgbox( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_DIALOGBOX, 5, "answer_Generic" );
    cr.Say( SAY_DIALOGBOX_TEXT, "Choose you button dude." );
    cr.Say( SAY_DIALOGBOX_BUTTON( 0 ), "Button0" );
    cr.Say( SAY_DIALOGBOX_BUTTON( 1 ), "Button1" );
    cr.Say( SAY_DIALOGBOX_BUTTON( 2 ), "Button2" );
    cr.Say( SAY_DIALOGBOX_BUTTON( 3 ), "Button3" );
    cr.Say( SAY_DIALOGBOX_BUTTON( 4 ), "Button4" );
}

void skillbox( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_SKILLBOX, 0, "answer_Generic" );
}

void say( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_SAY, p0, "answer_Generic" );
    cr.Say( SAY_SAY_TITLE, "Choose you..." );
    cr.Say( SAY_SAY_TEXT, "sometext" );
}

void timer( Critter& cr, int p0, int p1, int p2 )
{
    ProtoItem@ proto = GetProtoItem( PID_BOTTLE_CAPS );
    cr.ShowScreen( SCREEN_TIMER, proto.PicInv, "answer_Generic" );
}

void bag( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_BAG, 0, "answer_Generic" );
}

void inventory( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_INVENTORY, 0, "" );
}

void cha( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_CHARACTER, 0, "" );
}

void fixboy( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_FIXBOY, 0, "" );
}

void pipboy( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_PIPBOY, 0, "" );
}

void minimap( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_MINIMAP, 0, "" );
}

void close( Critter& cr, int p0, int p1, int p2 )
{
    cr.ShowScreen( SCREEN_CLOSE, 0, "" );
}









// ok, just predictable log message about null pointer exception
// string@ SomeFunc(string& str)

// results in ICE: Assertion failed: tempVariables.GetLength() == 0, file ..\..\source\as_compiler.cpp, line 611
// string SomeFunc(string& str)

// crash
/*string SomeFunc(string& str)
   {
        string@[]@ forms = split(str, " ");
           // uncomment to reproduce crash
        // SomeFunc1(forms);
        return null;
   }

   void SomeFunc1(string@[]@ arr)
   {
        Log("Ok");
   }*/




void DLog( string& str )
{
    Log( str );
}


#include "_macros.fos"
#include "entire.fos"

// ent number for i-th room
// global value, but we can change it to be different per-npc
#define ENT    # (i)        ( 50 + i )



class SomeClassA
{
    int A;

    ~SomeClassA()
    {
        Log( "destruct" );
    }
}

class SomeClassB
{
    SomeClassA@ nullptr;
    SomeClassB( SomeClassA@ aPtr )
    {
        this.nullptr.A = 100;       // Null pointer access, but after this class a is destroyed
    }
}

void test10( Critter& crit, int p0, int p1, int p2 )
{
    SomeClassA a;
    SomeClassB( a );
}
/*
   void test11(Critter& cr, int p0, int p1, int p2)
   {
        Critter@ npc=GetCritter(uint(p0)+5000000);
        if(not valid(npc)) return;

        npc.SetEvent(CRITTER_EVENT_PLANE_BEGIN,"_Begin");
        npc.SetEvent(CRITTER_EVENT_PLANE_END,"_End");

        NpcPlane@ plane=CreatePlane();
        plane.Type=AI_PLANE_WALK;
        plane.Priority=0;
        plane.Walk_HexX=p1;
        plane.Walk_HexY=p2;
        plane.Walk_Run=false;
        plane.Walk_Cut=0;

        NpcPlane@ plane2=CreatePlane();
        @plane.Child=plane2;
        plane2.Type=AI_PLANE_WALK;
        plane2.Priority=0;
        plane2.Walk_HexX=p1+10;
        plane2.Walk_HexY=p2;
        plane2.Walk_Run=false;
        plane2.Walk_Cut=0;

        npc.AddPlane(plane);
   }*/

void _Begin( Critter& crit, NpcPlane& plane, int reason )
{
    Log( "Begin, reason: " + reason + "." );
}

void _End( Critter& crit, NpcPlane& plane, int reason )
{
    Log( "End, reason: " + reason + "." );
}

#include "npc_planes.fos"
void test12( Critter& cr, int p0, int p1, int p2 )
{
    Critter@ npc = GetCritter( uint( p0 ) + 5000000 );
    if( not valid( npc ) )
        return;

    AddWalkPlane( npc, 2, cr.HexX, cr.HexY, cr.Dir, false, 2 );
    AddMiscPlane( npc, 1, __FullSecond + 3 * 60, null );
}

void plane_Misc( Critter& npc )
{
    npc.Say( SAY_NORM, "Ho-ho-ho." );
}


void test13( Critter& cr, int p0, int p1, int p2 )
{
    Map@ map = cr.GetMap();
    Log( "begin" );
    if( map.Reload() )
        Log( "ok" );
}

void test14( Critter& cr, int p0, int p1, int p2 )
{
    Map@ location = cr.GetMap();
    Log( "begin loc" );
    if( location.Reload() )
        Log( "ok" );
}

void test15( Critter& cr, int p0, int p1, int p2 )
{
    cr.RunClientScript( "__Test", p0, p1, p2, null, null );
}

void test16( Critter& cr, int p0, int p1, int p2 )
{
    uint[] ui( 3 );
    ui[ 0 ] = p0;
    ui[ 1 ] = p1;
    ui[ 2 ] = p2;
    CreateTimeEvent( __FullSecond + 5 * 60, "e_Test", ui, true );
}

uint e_Test( uint[] @ values )
{
    Log( "Values (" + values.length() + "): " + values[ 0 ] + ", " + values[ 1 ] + ", " + values[ 2 ] + "." );
    return REAL_SECOND( 5 );
}

void test17( Critter& cr, int p0, int p1, int p2 )
{
    Log( "Show callback." );
}

void testGroup( Critter& cr, int p0, int p1, int p2 )
{
    Critter@ npc = GetCritter( uint( p0 ) + 5000000 );
    if( not valid( npc ) )
        return;
    Critter@ npc2 = GetCritter( uint( p1 ) + 5000000 );
    if( not valid( npc2 ) )
        return;

    Critter@[] group( 2 );
    @group[ 0 ] = npc;
    @group[ 1 ] = npc2;

    cr.TransitToGlobal( group );
}

void testLex( Critter& cr, int p0, int p1, int p2 )
{
    Item@[] items;
    cr.GetItems( -1, items );
    for( uint i = 0; i < items.length(); i++ )
        items[ i ].SetLexems( "$Number" + Random( 100, 200 ) );

    Critter@ npc = GetCritter( uint( p0 ) + 5000000 );
    if( not valid( npc ) )
        return;

    npc.SetLexems( "$name" + "Dude" );
    Log( "Done" );
}

void testFly( Critter& cr, int p0, int p1, int p2 )
{
    Log( "x " + cr.HexX + " y " + cr.HexY );
    cr.GetMap().RunFlyEffect( p0, null, null, cr.HexX, cr.HexY, p1, p2 );
}

void testDelItem( Critter& cr, int p0, int p1, int p2 )
{
    Critter@ cl = GetCritter( uint( p0 ) );
    if( not valid( cl ) )
        return;
    DeleteItem( cl.GetItem( 0, p1 ) );
}

void testSwap( Critter& cr, int p0, int p1, int p2 )
{
    Critter@ cr1 = GetCritter( uint( p0 ) );
    Critter@ cr2 = GetCritter( uint( p1 ) );
    SwapCritters( cr1, cr2, true, true );
}


/*#pragma globalvar "bool aaaa = true"
  #pragma globalvar "bool aaaa = true"
  #pragma globalvar "bool aaaa = true"
  #pragma globalvar "bool aaaa = true"
#pragma globalvar "bool aaaa = true"*/


void test_find( Critter& cr, int p0, int p1, int param2 )
{
    Map@ map = cr.GetMap();
    int  f = 0;
    switch( p0 )
    {
    case 0:
        f = FIND_LIFE;
        break;
    case 1:
        f = FIND_KO;
        break;
    case 2:
        f = FIND_DEAD;
        break;
    case 3:
        f = FIND_LIFE_AND_KO;
        break;
    case 4:
        f = FIND_LIFE_AND_DEAD;
        break;
    case 5:
        f = FIND_KO_AND_DEAD;
        break;
    case 6:
        f = FIND_ALL;
        break;
    }
    uint count = map.GetNpcCount( param2, f );
    for( uint i = 0; i < count; i++ )
    {
        Critter@ cow = map.GetNpc( param2, f, i );
        map.SetText( cow.HexX, cow.HexY, COLOR_RGB( 255, 0, 0 ), "" + count );
    }
    cr.Say( SAY_NORM_ON_HEAD, "" + f );
}


import void AffectRadiation( Critter& cr, int value ) from "radiation";
import void AffectPoison( Critter& cr, int value ) from "poison";

void testPlague( Critter& cr, int isRad, int value, int p2 )
{
    if( isRad != 0 )
        AffectRadiation( cr, value );
    else
        AffectPoison( cr, value );
    cr.Say( SAY_NETMSG, "rad " + cr.Stat[ ST_RADIATION_LEVEL ] );
    cr.Say( SAY_NETMSG, "psn " + cr.Stat[ ST_POISONING_LEVEL ] );
}

void LocInfo( Critter& cr, int isRad, int value, int p2 )
{
    Location@ loc = cr.GetMap().GetLocation();
    cr.Say( SAY_NETMSG, "MapPid " + cr.GetMap().GetProtoId() );
    cr.Say( SAY_NETMSG, "LocPid " + loc.GetProtoId() );
    cr.Say( SAY_NETMSG, "Visible " + ( loc.Visible ? "true" : "false" ) );
    cr.Say( SAY_NETMSG, "GeckVisible " + ( loc.GeckVisible ? "true" : "false" ) );
    cr.Say( SAY_NETMSG, "AutoGarbage " + ( loc.AutoGarbage ? "true" : "false" ) );
    cr.Say( SAY_NETMSG, "GeckCount " + loc.GeckCount );
    cr.Say( SAY_NETMSG, "Radius " + loc.Radius );
}

void GetCrIds( Critter& cr, int onlyNpc, int alive, int )
{
    Map@ map = cr.GetMap();
    if( valid( map ) )
    {
        Critter@[] critters;
        for( uint i = 0, j = map.GetCritters( 0, ( alive == 1 ? FIND_LIFE_AND_KO : FIND_ALL ) | ( onlyNpc == 1 ? FIND_ONLY_NPC : 0 ), critters ); i < j; i++ )
            cr.Say( SAY_NETMSG, critters[ i ].Name + " " + critters[ i ].Id +" X "+critters[ i ].HexX + " Y " +critters[ i ].HexY);
    }
}

void CrAddItem( Critter& cr, int crId, int pid, int count )
{
    Critter@ toCr = GetCritter( crId );
    if( valid( toCr ) )
        toCr.AddItem( pid, count );
}

void AddExp( Critter& cr, int crId, int val, int )
{
    Critter@ toCr = GetCritter( crId );
    if( valid( toCr ) )
        toCr.StatBase[ ST_EXPERIENCE ] += val;
}

void SetStat( Critter& cr, int crId, int num, int val )
{
    Critter@ toCr = GetCritter( crId );
    if( valid( toCr ) )
        toCr.StatBase[ num ] = val;
}

void SetSkill( Critter& cr, int crId, int num, int val )
{
    Critter@ toCr = GetCritter( crId );
    if( valid( toCr ) )
        toCr.SkillBase[ num ] = val;
}

void SetPerk( Critter& cr, int crId, int num, int val )
{
    Critter@ toCr = GetCritter( crId );
    if( valid( toCr ) )
        toCr.PerkBase[ num ] = val;
}

/*
   import void ExplodeEx(Map& map, uint16 hexX, uint16 hexY, uint16 effectPid, uint effectRadius, uint damage, uint damageType, uint damageRadius, uint ownerId) from "explode";

   void Boom(Critter& cr, int damage, int damageRadius, int effRadius)
   {
        Map@ map=cr.GetMap();
        if(valid(map)) ExplodeEx(map,cr.HexX,cr.HexY,PID_EXPLODE_ROCKET,effRadius,damage,DAMAGE_EXPLODE,damageRadius,0);
   }
 */

void TestLoc( Critter& cr, int locPid, int count, int )
{
    for( int i = 0; i < count; i++ )
    {
        Location@ loc = GetLocation( CreateLocation( locPid, 100, 100, null ) );
        Map@      map = loc.GetMapByIndex( 0 );
        Critter@[] critters;
        uint      crCount = map.GetCritters( 0, FIND_ALL, critters );
        for( uint j = 0; j < crCount; j++ )
        {
            for( uint k = 0; k < crCount; k++ )
            {
                if( j != k )
                    AddAttackPlane( critters[ j ], 0, critters[ k ] );
            }
        }
    }
}

void TestWorld( Critter& cr, int, int, int )
{
    // 1000 locations and maps
    // 100000 items
    // 5000 npc
    for( uint i = 0; i < 1000; i++ )
        CreateLocation( 101, 100, 100, null );
    // 242000
    for( uint i = 0; i < 242000; i++ )
        GetLocalVar( 3040, i );
    for( uint i = 0; i < 87000; i++ )
        GetUnicumVar( 2020, i, i );


// npc 7300 +
// uvar 87000 +
// lvar 242000 +
// holo 110 -
// maps 708 +
// loc 524 +
// items 105000 +
// anyd 1800 -
}

void CrClearInv( Critter& cr, int crId, int, int )
{
    Critter@ toCr = GetCritter( crId );
    if( valid( toCr ) )
    {
        Item@[] items;
        toCr.GetItems( -1, items );
        for( uint i = 0, j = items.length(); i < j; i++ )
            DeleteItem( items[ i ] );
    }
}

void ShowContainer(Critter& cr, int crId, int, int)
{
	Critter@ targetCr = GetCritter( crId );
    if( valid( targetCr ) )
    {
        cr.ShowContainer(targetCr, null, TRANSFER_CRIT_LOOT);
    }
}

void SetType( Critter& cr, int crId, int crType, int )
{
    Critter@ toCr = GetCritter( crId );
    if( valid( toCr ) )
    {
        toCr.ChangeCrType( crType );
        toCr.StatBase[ ST_BASE_CRTYPE ] = crType;
    }
}

void ChangeLook( Critter& cr, int, int, int )
{}

import void ExplodeEx( Map& map, uint16 hexX, uint16 hexY, uint16 effectPid, uint effectRadius, uint damage, uint damageType, uint damageRadius, uint ownerId ) from "explode";
void        Boom( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ALL | FIND_LIFE_AND_KO, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        if( critters[ i ].Id != cr.Id )
            ExplodeEx( cr.GetMap(), critters[ i ].HexX, critters[ i ].HexY, PID_EXPLODE_ROCKET, 3, 666, DAMAGE_EXPLODE, 3, 0 );
    }
}

/*void Patch0( Critter& cr, int, int, int )
{
    Log( "Begin patch..." );
    Critter@[] npcs;
    GetAllNpc( 0, npcs );
    for( uint i = 0, j = npcs.length(); i < j; i++ )
    {
        Critter@ npc = npcs[ i ];
        Map@     map = npc.GetMap();
        if( valid( map ) )
        {
            uint16 locPid = map.GetLocation().GetProtoId();
            // if(LOCATION_IS_CITY(locPid)) npc.Refresh();
        }
    }

    Location@ locHell = GetLocationByPid( LOCATION_ReplicationHell, 0 );
    locHell.Reload();
    Log( "End patch." );
}
*/

void RandomTypes( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ONLY_PLAYERS | FIND_LIFE_AND_KO, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        if( critters[ i ].Id != cr.Id )
        {
            int type = Random( 20, 90 );
            critters[ i ].ChangeCrType( type );
            critters[ i ].StatBase[ ST_BASE_CRTYPE ] = type;
        }
    }
}

void AllToVaultBoys( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ONLY_PLAYERS | FIND_ALL, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        if( critters[ i ].Id != cr.Id )
        {
            critters[ i ].ChangeCrType( 249 );
            critters[ i ].StatBase[ ST_BASE_CRTYPE ] = 249;
        }
    }
}

void AllMapsEveryBoom( Critter& cr, int, int, int )
{
    Map@[] maps;
    ::GetAllMaps( 0, maps );
    for( uint i = 0, j = maps.length(); i < j; i++ )
    {
        Map@   map = maps[ i ];
        uint16 locPid = map.GetLocation().GetProtoId();
        if( LOCATION_IS_CITY( locPid ) )
            CreateTimeEvent( __FullSecond, "e_Boom", map.Id, false );
    }
}

void AllMapsClean( Critter& cr, int, int, int )
{
    Location@[] locs;
    ::GetAllLocations( 0, locs );
    for( uint i = 0, j = locs.length(); i < j; i++ )
    {
        Location@   loc = locs[ i ];
        //uint16 locPid = map.GetLocation().GetProtoId();
		if (loc.IsQuest() )
			DeleteLocation(loc.Id);

		
    }
}

void RandomEveryBoom( Critter& cr, int, int, int )
{
    CreateTimeEvent( __FullSecond, "e_Boom", cr.GetMap().Id, true );
}

uint e_Boom( uint[] @ values )
{
    Map@ map = GetMap( values[ 0 ] );
    if( valid( map ) )
    {
        for( int i = 0; i < 4; i++ )
            ExplodeEx( map, Random( 10, map.GetWidth() - 10 ), Random( 10, map.GetHeight() - 10 ), PID_EXPLODE_ROCKET, 3, 666, DAMAGE_EXPLODE, 3, 0 );
    }
    return REAL_SECOND( Random( 1, 4 ) );
}

void AllToLife( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_DEAD | FIND_ONLY_PLAYERS, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        critters[ i ].ToLife();
    }
}

void NpcToLife( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_DEAD | FIND_ONLY_NPC, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        critters[ i ].ToLife();
    }
}

void AllToDead( Critter& cr, int deadType, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ALL | FIND_ONLY_PLAYERS, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        critters[ i ].ToDead( deadType, null );
    }
}

void ShowIds( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ALL, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
        critters[ i ].Say( SAY_NORM_ON_HEAD, "My id is " + critters[ i ].Id );
}

void SetDustyScript( Critter& cr, int dustyId, int, int )
{
    Critter@ dusty = GetCritter( dustyId );
    if( valid( dusty ) )
        dusty.SetScript( "ncr_dusty@_DustyInit" );
}

void TestIndex( Critter& cr, int i, int, int )
{
    cr.StatBase[ ST_STRENGTH ] = 20;
    const int ii = cr.Stat[ ST_STRENGTH ];
    Log( "Strenght " + cr.Stat[ ST_STRENGTH ] );
}

void Transit( Critter& cr, int hx, int hy, int )
{
    cr.TransitToHex( hx, hy, 6 );
}

void GlobalCar( Critter& iam, int crId, int, int )
{
    Critter@ cr = ::GetCritter( crId );
    if( valid( cr ) )
    {
        Item@[] items;
        cr.GetItemsByType( ITEM_TYPE_CAR, items );
        for( uint i = 0; i < items.length(); i++ )
        {
            Item@ car = items[ i ];
            car.Charge = car.Proto.Car_TankVolume;
            car.Deterioration = 0;
            car.Update();
            iam.Say( SAY_NETMSG, "Done." );
        }
    }
}

void NullPtr( Critter& iam, int crId, int, int )
{
    Critter@ cr = GetCritter( 666 );
    if( iam.SkillBase[ 555 ] == 11 )
        crId = 0;
}

void AddHellTurret( Critter& iam, int pid, int, int )
{
    Map@     map = iam.GetMap();
    uint16   hx = iam.HexX, hy = iam.HexY;
    map.MoveHexByDir( hx, hy, iam.Dir, 1 );
    Critter@ turret = map.AddNpc( pid != 0 ? pid : 480, hx, hy, iam.Dir, null, null, null );
    turret.SetScript( "replication_hell@_TurretInit" );
}

uint NpcCrazyId = 0;
void NpcCrazyEvent( Critter& cr, int off, int, int )
{
    if( off != 0 )
        EraseTimeEvent( NpcCrazyId );
    else
        NpcCrazyId = CreateTimeEvent( __FullSecond, "e_NpcCrazy", cr.GetMap().Id, false );
}

uint e_NpcCrazy( uint[] @ values )
{
    Map@ map = GetMap( values[ 0 ] );
    Critter@[] critters;
    map.GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        Critter@[] players;
        map.GetCritters( 0, FIND_LIFE_AND_KO | FIND_ONLY_PLAYERS, players );
        for( uint l = 0, m = players.length(); l < m; l++ )
            AddAttackPlane( critters[ i ], 0, players[ l ] );
    }
    return REAL_SECOND( Random( 10, 40 ) );
}

void AddMadRobot( Critter& iam, int, int, int )
{
    Map@     map = iam.GetMap();
    uint16   hx = iam.HexX, hy = iam.HexY;
    map.MoveHexByDir( hx, hy, iam.Dir, 1 );
    Critter@ turret = map.AddNpc( 480, hx, hy, iam.Dir, null, null, null );
    turret.StatBase[ ST_TEAM_ID ] = 19;
    turret.SetScript( "replication_hell@_TurretInit" );
//	turret.SetStat(ST_REPLICATION_TIME,1);
//	turret.SetPerk(PE_TERMINATOR,1);
    turret.AddItem( 520, 2 );
}

void AllNpcSetParam( Critter& cr, int index, int value, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
        critters[ i ].ParamBase[ index ] = value;
}

void AddGuard( Critter& cr, int, int, int )
{
    //int[] params = { ST_DIALOG_ID, 2200, ST_TEAM_ID, 5 };
    //int[] items = { PID_END_BOSS_PLASMA_GUN, 3, SLOT_INV };
    //Critter@ guard = cr.GetMap().AddNpc( 369, cr.HexX, cr.HexY - 1, 2, params, items, "map_barter_ground@_GuardInit" );
}

void NpcFullDead( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        critters[ i ].StatBase[ ST_REPLICATION_TIME ] = -1;
        critters[ i ].ToDead( 1, null );
    }
}

void NpcReturn( Critter& cr, int replTime, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        critters[ i ].StatBase[ ST_REPLICATION_TIME ] = replTime;
        critters[ i ].ToLife();
    }
}

#include "_npc_pids.fos"
const uint16[] pids = { 54, 54, 54, 54, NPC_PID_MaleOrphan, NPC_PID_FemaleOrphan, NPC_PID_HealthyFemaleSlave, NPC_PID_HealthyMaleSlave, NPC_PID_HealthyFemaleSlave, NPC_PID_HealthyMaleSlave, NPC_PID_HealthyFemaleSlave, NPC_PID_HealthyMaleSlave, NPC_PID_MaleOrphan, NPC_PID_FemaleOrphan, NPC_PID_HealthyFemaleSlave, NPC_PID_HealthyMaleSlave, NPC_PID_AverageMerchantMale, NPC_PID_WeakMeleeGuardMale, NPC_PID_RaiderMale, NPC_PID_RaiderFemale };

void AddHostile( Critter& iam, int, int, int )
{
    Map@     map = iam.GetMap();
    uint16   hx = iam.HexX, hy = iam.HexY;
    map.MoveHexByDir( hx, hy, iam.Dir, 1 );
    Critter@ hostile = map.AddNpc( pids[ Random( 0, pids.length() - 1 ) ], hx, hy, iam.Dir, null, null, null );
    hostile.StatBase[ ST_TEAM_ID ] = 19;
    // hostile.SetStat(ST_REPLICATION_TIME,Random(5,10));
    CreateTimeEvent( __FullSecond, "e_HostileMove", hostile.Id, true );
}

uint SufferingLastTime = 0;
uint e_HostileMove( uint[] @ values )
{
    Critter@ hostile = ::GetCritter( values[ 0 ] );
    if( not valid( hostile ) )
        return 0;

    if( hostile.IsLife() )
    {
        hostile.MoveRandom();

        if( __FullSecond > SufferingLastTime )
        {
            string say;
            switch( Random( 0, 50 ) )
            {
            case 0:
                say = "Малые страдания выводят нас из себя, великие же - возвращают нас самим себе.";
                break;
            case 1:
                say = "Минутное удовольствие часто бывает причиной долгих страданий. ";
                break;
            case 2:
                say = "Кто боится страдания, тот уже страдает от боязни.";
                break;
            case 3:
                say = "Язвы желудка возникают не от того, что вы едите, а от того, что съедает вас. ";
                break;
            case 4:
                say = "Бедное раздавленное насекомое страдает так же, как умирающий гигант. ";
                break;
            case 5:
                say = "Молчание - величайшее из человеческих страданий; святые никогда не молчали. ";
                break;
            case 6:
                say = "Раны, нанесенные собственной рукой, всегда заживают медленнее, чем те, которые нанес противник. ";
                break;
            case 7:
                say = "Не умеешь нести бремя невзгод - усугубляешь их тяжесть. ";
                break;
            case 8:
                say = "Есть два способа преодолевать трудности: либо вы изменяете сами трудности, чтобы было легче с ними справится, либо, справляясь с ними изменяетесь сами. ";
                break;
            case 9:
                say = "Если мы еще можем любить тех, кто заставил нас страдать, то любовь наша лишь становится сильнее.  ";
                break;
            case 10:
                say = "Мужественный человек обыкновенно страдает, не жалуясь, человек же слабый жалуется, не страдая.";
                break;
            case 11:
                say = "Величайшее зло - страдание.";
                break;
            case 12:
                say = "Всеми страданиями вокруг нас должны страдать и мы. У всех у нас не одно тело, но одно развитие, а это проводит нас через все боли в той или иной форме. Как дитя проходит в своем развитии через все стадии жизни вплоть до старости и до смерти (и каждая стадия, в сущности, от страха или от желания, кажется предыдущей недостижимою), точно так же и мы (связанные с человечеством не менее глубоко, чем с самими собой) проходим в своем развитии через все страдания этого мира. Справедливости при таком положении нет места, но нет места и страху перед страданием или возможности истолковать страдание как заслугу.";
                break;
            case 13:
                say = "Издевательство над чужими страданиями не должно быть прощаемо.";
                break;
            case 14:
                say = "К величию есть только один путь, и этот путь проходит через страдания.";
                break;
            case 15:
                say = "Когда мне не дают роли, чувствую себя пианисткой, которой отрубили руки.";
                break;
            case 16:
                say = "Мы стремимся в большей степени к тому, чтобы отвести от себя страдания, нежели к тому, чтобы получить удовольствие.";
                break;
            case 17:
                say = "Обусловленное существование есть страдание. У страдания есть причина. У страдания есть конец, и есть пути, ведущие к этому концу.";
                break;
            case 18:
                say = "Только здесь страдать – это страдать. Не в том смысле, что те, кто страдает здесь, где-то в другом месте из-за этого страдания будут возвышенны, а в том смысле, что то, что именуется в этом мире страданием, в другом мире не изменяется, а только освобождено от своей противоположности, блаженства.";
                break;
            case 19:
                say = "Ты можешь отстраняться от страданий мира, это тебе разрешается и соответствует твоей природе, но, быть может, как раз это отстранение и есть единственное страдание, которого ты мог бы избежать.";
                break;
            case 20:
                say = "Человеческий разум может излечить от иллюзий, но не от страданий.";
                break;
            case 21:
                say = "Чем больше любят, тем больше страдают. Вся возможная для каждой души боль пропорциональна степени ее совершенства.";
                break;
            case 22:
                say = "Мудрый не горюет о потерянном, об умершем и о прошлом. Тем он отличается от глупца.";
                break;
            case 23:
                say = "Размышляй об изгнании, пытках, войнах, болезнях, кораблекрушениях, чтобы не быть новичком ни при каких бедствиях.";
                break;
            case 24:
                say = "Подлинное душевное спокойствие достигается примирением с самым худшим.";
                break;
            case 25:
                say = "Кто страдает раньше, чем это необходимо, тот страдает больше необходимого.";
                break;
            case 26:
                say = "Кто боится страданий, тот уже страдает от боязни.";
                break;
            case 27:
                say = "Ничтожным не бывает то, что больно нам.";
                break;
            case 28:
                say = "Моря человеческих слез не были бы так огромны, если бы не были бы так мелки.";
                break;
            case 29:
                say = "Чувствительный человек – точно безоружный среди хорошо вооруженных.";
                break;
            case 30:
                say = "Люди не бывают очень несчастны, если им не в чем раскаиваться.";
                break;
            case 31:
                say = "Чужие бедствия могут быть поводом к безропотности, но не к утешению.";
                break;
            case 32:
                say = "Огорчение существует не само по себе, а в нашем представлении.";
                break;
            case 33:
                say = "Мы созданы для несчастий. Слезы для сердца, что вода для рыб.";
                break;
            case 34:
                say = "В этом мире самым надежным развлечением для нас являются тревоги и страдания.";
                break;
            case 35:
                say = "Наш мир есть ничто иное, как скопление громадных страданий.";
                break;
            case 36:
                say = "Горечь – единственное накопление человека в жизни.";
                break;
            case 37:
                say = "Единственный способ быть счастливым – это любить страдания.";
                break;
            case 38:
                say = "В жизни, как и в природе, бывает гораздо больше пасмурных дней, чем безоблачных.";
                break;
            case 39:
                say = "Не чувствовать страданий не свойственно человеку, а не уметь их переносить не подобает мужчине.";
                break;
            case 40:
                say = "Ни с кем не случается ничего такого, что он не в силах был бы вынести.";
                break;
            case 41:
                say = "Мужайтесь и храните себя для благоприятных времен.";
                break;
            case 42:
                say = "Переноси с достоинством то, что изменить не сможешь.";
                break;
            case 43:
                say = "Кто переносит нетерпеливо, тот страдает вдвойне.";
                break;
            case 44:
                say = "Слезы для женщины – облегчение, для мужчины – пытка.";
                break;
            case 45:
                say = "Хочешь быть счастливым – выучись сперва страдать.";
                break;
            default:
                break;
            }
            if( say != "" )
                hostile.Say( SAY_NORM, say );
            SufferingLastTime = __FullSecond + Random( 3, 6 ) * 60;
        }
        else if( Random( 0, 100 ) == 0 )
            ExplodeEx( hostile.GetMap(), hostile.HexX, hostile.HexY, PID_EXPLODE_ROCKET, 10, 666, DAMAGE_EXPLODE, 10, 0 );
    }

    return REAL_SECOND( Random( 10, 20 ) );
}

void AttackTurret( Critter& cr, int, int, int )
{
    Critter@ turret;
    Map@     map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        if( critters[ i ].GetProtoId() == 480 )
        {
            @turret = critters[ i ];
            break;
        }

    }

    critters.resize( 0 );
    map.GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        if( critters[ i ].GetProtoId() != 480 )
        {
            AddAttackPlane( critters[ i ], 100, turret );
        }
    }
}


void TurretFrags( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        if( critters[ i ].GetProtoId() == 480 )
        {
            CreateTimeEvent( __FullSecond, "e_HostileMove", critters[ i ].Id, true );
            break;
        }

    }
}

uint e_TurretFrags( uint[] @ values )
{
    Critter@ turret = ::GetCritter( values[ 0 ] );
    uint     frags = 0; // =turret.GetKill(BT_MEN)+turret.GetKill(BT_WOMEN)+turret.GetKill(BT_CHILDREN);
    turret.Say( SAY_NORM_ON_HEAD, "Frags " + frags );
    return REAL_SECOND( 3 );
}

void TurretParam( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    Critter@[] critters;
    map.GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        critters[ i ].StatBase[ ST_BONUS_LOOK ] = 1000;
    }
}

void CreateCar( Critter& cr, int pid, int ox, int oy )
{
    Item@ car = cr.GetMap().AddItem( cr.HexX + ox, cr.HexY + oy, pid, 1 );
    if( not valid( car ) || car.GetType() != ITEM_TYPE_CAR )
        return;

    car.Charge = car.Proto.Car_TankVolume;
    car.Deterioration = 0;

    uint keyId = Random( 10000, 50000 );
    car.LockerId = keyId;
    car.LockerComplexity = 1000;
    car.GetChild( 0 ).LockerId = keyId;
    car.GetChild( 0 ).LockerComplexity = 1000;
    cr.AddItem( PID_BLUE_PASS_KEY, 1 ).LockerId = keyId;

    car.Update();
    cr.Say( SAY_NETMSG, "Done." );
}

void CreateCarPersonal( Critter& cr, int pid, int crId, int oy )
{
    Item@ car = cr.GetMap().AddItem( cr.HexX, cr.HexY + oy, pid, 1 );
    if( not valid( car ) || car.GetType() != ITEM_TYPE_CAR )
        return;

    car.Charge = car.Proto.Car_TankVolume;
    car.Deterioration = 0;
    _CarSetNoLockpick( car );

    uint keyId = _CritEyesDoorId( crId );
    car.LockerId = keyId;
    car.LockerComplexity = 1000;
    car.GetChild( 0 ).LockerId = keyId;
    car.GetChild( 0 ).LockerComplexity = 1000;

    car.Update();
    cr.Say( SAY_NETMSG, "Done." );
}

void AllTo3d( Critter& cr, int, int, int )
{
    Critter@[] critters;
    cr.GetMap().GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        int rnd = Random( 290, 316 );
        critters[ i ].ChangeCrType( rnd );
        critters[ i ].StatBase[ ST_BASE_CRTYPE ] = rnd;
    }
}

void TestLexem( Critter& cr, int, int, int )
{
    Item@ item = cr.GetItem( 0, SLOT_HAND1 );
    if( valid( item ) )
    {
        item.SetLexems( "test test test" );
        item.Update();
    }
}

class Prop
{
    void set_Test( uint value ) {}
    uint get_Test() const       { return 0; }
};
void TestProp( Critter& cr, int, int, int )
{
    Prop p;
    uint i = ( p.Test - 1 );
}

// #pragma bindfunc "uint TestFunc(int, int) -> fo_test.dll TestFunc"
/*#pragma bindfunc "uint TestFunc(int, int) -> fo_test.dll TestFunc"
   #pragma bindfunc "bool Critter::TestMethod(int, uint, bool) -> fo_test.dll Critter_TestMethod"

   void TestDll(Critter& cr, int, int, int)
   {
        int i = TestFunc(1, 2);
        Log("TestFunc = " + i);

        i = cr.TestMethod(1, 2, true) ? 1 : 0;
        Log("TestMethod " + i);

        cr.SetEvent(CRITTER_EVENT_TALK, " fo_test.dll @ EventTalk ");
        i = cr.EventTalk(cr, true,666) ? 1 : 0;
        Log("EventTalk " + i);
   }*/

void TestScriptTimeout( Critter& cr, int, int, int )
{
    Test2();
}
void Test2()
{
    Test3();
}
void Test3()
{
    int ggg = 1;
    do
    {
        ggg = Random( 1, 100 );
    }
    while( ggg != 0 );
}

void TestNullptr( Critter&, int, int, int )
{
    Critter@ cr;
    Log( "begin" );
    uint     id = cr.Id;
    Log( "end" );
}

// Synchronizer TestLocker;
void TestScriptConcurrent( Critter& cr, int test, int, int )
{
    // TestLocker.Lock();

    Synchronize();
    Map@ map = cr.GetMap();
    Resynchronize();

    if( test == 1 )
        Resynchronize();             // Invalid call
    else if( test == 2 )
        Synchronize();               // Call without Resynchronize

    if( test == 5 )
    {
        for( int i = 0; i < 1000; i++ )
            CreateTimeEvent( 0, "e_TestScriptConcurrent", false );
    }
}

int Data = 0;
uint e_TestScriptConcurrent( uint[] @ values )
{
    // TestLocker.Lock();

    if( Data == 0 )
        Data++;
    else if( Data == 1 )
        Data--;
    else
        Log( "Fail!" );
    return 1;
}

void TestLog( Critter& cr, int, int, int )
{
    for( uint i = 0; i < 10000; i++ )
        Log( "Test message " + i );
}

void TestMapLoop( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    map.SetEvent( MAP_EVENT_LOOP_3, "_MapLoopEvent" );
    map.SetLoopTime( 3, 1000 );
    Log( "ok" );
}

void _MapLoopEvent( Map& map )
{
    Log( "_MapLoopEvent " + map.Id );
}

void patchBunker( Critter& cr, int, int, int )
{
    Location @ loc = GetLocationByPid( 21, 0 );    // LOCATION_TechBunker(21)
    if( @loc != null )
    {
        uint locId = loc.Id;
        DeleteLocation( locId );
        cr.Say( 11, "Location deleted. Id" + locId );     // SAY_NETMSG (11)
    }

    uint id = CreateLocation( 21, 1000, 1397, null );
    if( id == 0 )
    {
        cr.Say( 11, "Create location error: " + GetLastError() );
        return;
    }
    @ loc = GetLocation( id );

    if( @loc == null )
    {
        cr.Say( 11, "Get location error: " + GetLastError() );
        return;
    }

    loc.Visible = false;
    loc.GeckVisible = false;
    loc.AutoGarbage = false;
    loc.Radius = 6;
}

import void ClearPermanentDeath() from "replication";
void        ClearPermanentDeath( Critter& cr, int, int, int )
{
    ClearPermanentDeath();
}

void TestBlockItem( Critter& cr, int, int, int )
{
    Item@ item = cr.GetMap().AddItem( cr.HexX, cr.HexY, PID_RADIO, 1 );
    item.SetEvent( ITEM_EVENT_SKILL, "_ChangeMode" );
    UNSETFLAG( item.Flags, ITEM_NO_BLOCK );
}

bool _ChangeMode( Item& item, Critter& cr, int skill )
{
    if( FLAG( item.Flags, ITEM_NO_BLOCK ) )
    {
        UNSETFLAG( item.Flags, ITEM_NO_BLOCK );
    }
    else
    {
        SETFLAG( item.Flags, ITEM_NO_BLOCK );
    }
    item.Update();
    return false;
}

void DeleteTimeEvent( Critter& cr, int id, int, int )
{
    ::EraseTimeEvent( uint( id ) );
}

void HandToGround( Critter& cr, int, int, int )
{
    Item@ item = cr.GetItem( 0, SLOT_HAND1 );
    if( valid( item ) )
        ::MoveItem( item, 0, cr.GetMap(), cr.HexX, cr.HexY );
}

void PatchItemFlags( Critter& cr, int, int, int )
{
    Item@[] items;
    uint count = ::GetAllItems( 0, items );
    for( uint i = 0; i < count; i++ )
    {
        Item@ item = items[ i ];
        bool  canPickUp = false;
        switch( item.GetType() )
        {
        case ITEM_TYPE_ARMOR:
        case ITEM_TYPE_DRUG:
        case ITEM_TYPE_WEAPON:
        case ITEM_TYPE_AMMO:
        case ITEM_TYPE_MISC:
        case ITEM_TYPE_KEY:
            canPickUp = true;
            break;
        // case ITEM_TYPE_MISC_EX:
        case ITEM_TYPE_CONTAINER:
            canPickUp = FLAG( item.Flags, ITEM_CAN_PICKUP );
            break;
        case ITEM_TYPE_DOOR:
            SETFLAG( item.Flags, ITEM_NO_HIGHLIGHT );
            break;
        default:
            break;
        }
        switch( item.GetProtoId() )
        {
        case 148:
        case 150:
        case 154:
        case 156:
        case 850:
        case 851:
        case 852:
        case 854:
        case 855:
        case 856:
        case 857:
        case 858:
        case 859:
        case 860:
        case 861:
        case 862:
        case 863:
        case 864:
        case 865:
        case 866:
        case 867:
        case 868:
        case 869:
        case 870:
        case 871:
        case 872:
            canPickUp = false;
            break;
        default:
            break;
        }
        if( canPickUp )
            SETFLAG( item.Flags, ITEM_CAN_PICKUP );
        else
            UNSETFLAG( item.Flags, ITEM_CAN_PICKUP );
    }
}

void ColorizeHandItem( Critter& cr, int dist, int color, int flags )
{
    Item@ item = cr.GetItem( 0, SLOT_HAND1 );
    if( valid( item ) )
    {
        item.LightIntensity = Random( 30, 80 );
        item.LightColor = ( color != 0 ? color : Random( 0, 0xFFFFFF ) );
        item.LightDistance = ( dist != 0 ? dist : Random( 5, 15 ) );
        item.LightFlags = 0;

        if( ( flags % 10 ) == 1 )
        {
            _LightSetIgnoreDir( item, 0 );
            _LightSetIgnoreDir( item, 2 );
            _LightSetIgnoreDir( item, 4 );
        }
        else if( ( flags % 10 ) == 2 )
        {
            _LightSetIgnoreDir( item, 1 );
            _LightSetIgnoreDir( item, 3 );
            _LightSetIgnoreDir( item, 5 );
        }
        if( ( flags / 10 ) == 1 )
            _LightSetInverse( item );

        SETFLAG( item.Flags, ITEM_LIGHT );
        item.Update();
    }
}

void ColorizeHandItem2( Critter& cr, int dist, int color, int flags )
{
    Item@ item = cr.GetItem( 0, SLOT_HAND1 );
    if( valid( item ) )
    {
        item.LightColor = 0xFF000000 | ( color != 0 ? color : Random( 0, 0xFFFFFF ) );
        SETFLAG( item.Flags, ITEM_COLORIZE );
    }
}

void ColorizeLegsItem( Critter& cr, int dist, int color, int flags )
{
    Item@ item = cr.GetMap().GetItem( cr.HexX, cr.HexY, 0 );
    if( valid( item ) )
    {
        item.LightColor = 0xFF000000 | ( color != 0 ? color : Random( 0, 0xFFFFFF ) );
        // SETFLAG(item.Flags,ITEM_COLORIZE);
        item.Update();
    }
}

void ColorizeLegsItem2( Critter& cr, int dist, int color, int flags )
{
    Item@ item = cr.GetMap().GetItem( cr.HexX, cr.HexY, 0 );
    if( valid( item ) )
    {
        if( FLAG( item.Flags, ITEM_COLORIZE ) )
            UNSETFLAG( item.Flags, ITEM_COLORIZE );
        else
            SETFLAG( item.Flags, ITEM_COLORIZE );
    }
}

void PatchLight( Critter& cr, int, int, int )
{
    Item@[] items;
    uint count = ::GetAllItems( 0, items );
    for( uint i = 0; i < count; i++ )
    {
        Item@ item = items[ i ];
        if( item.LightIntensity != 0 || item.Proto.LightIntensity != 0 )
            SETFLAG( item.Flags, ITEM_LIGHT );
    }
}

void ItemFlags( Critter& cr, int, int, int )
{
    Item@[] items;
    uint count = cr.GetMap().GetItems( cr.HexX, cr.HexY, items );
    for( uint i = 0; i < count; i++ )
        cr.Say( SAY_NETMSG, "item " + items[ i ].GetProtoId() + " flags " + items[ i ].Flags );
}

void CheckAccess( Critter& cr, int, int, int )
{
    Critter@[] players;
	GetAllPlayers(players);
    for( uint i = 0; i < players.length(); i++ )
    {
        Critter@ player = players[ i ];
        if( player.GetAccess() > 0 )
            cr.Say( SAY_NETMSG, player.Name + " access " + player.GetAccess() + "." );
    }
    cr.Say( SAY_NETMSG, "Search complete." );
}

void Effect( Critter& cr, int radius, int, int )
{
    cr.GetMap().RunEffect( PID_EXPLODE_EMP, cr.HexX, cr.HexY + 10, radius );
}

void AddLoc( Critter& cr, int pid, int x, int y )
{
    if( ::CreateLocation( pid, x, y, null ) != 0 )
        cr.Say( SAY_NETMSG, "Success." );
    else
        cr.Say( SAY_NETMSG, "Fail." );
}

void DeleteNpc( Critter& cr, int crId, int, int )
{
    DeleteNpc( GetCritter( crId ) );
}

void TB( Critter& cr, int, int, int )
{
	Map@ map = cr.GetMap();
    map.BeginTurnBased(cr);
}

void SetTB( Critter& cr, int, int, int )
{
	Map@ map = cr.GetMap();
    map.SetTurnBasedAvailability( true );
}

void EndTB( Critter& cr, int, int, int )
{
    Map@ map = cr.GetMap();
    map.SetTurnBasedAvailability( false );
    map.EndTurnBased();
}

void TestVar( Critter& cr, int i, int, int )
{
    /*GameVar@ var=GetLocalVar(LMVAR_test_local_map,cr.GetMapId());
       Log("var="+var.GetValue());

       if(i!=0) var=i;

       Log("var="+var.GetValue());

       Log("begin vars generating");
       for(int i=1;i<1000000;i++)
       {
            GameVar@ var=GetLocalVar(LIVAR_test_local_item,i);
            var=Random(0,10);
            var=7;
       }
       Log("end vars generating");
     */
//	GVAR_test_global
//	LVAR_test_local
//	UVAR_test_unicum
//	LLVAR_test_local_loc
//	LMVAR_test_local_map
//	LIVAR_test_local_item
}

void TestTE( Critter& cr, int set, int, int )
{
    uint num = CreateTimeEvent( __FullSecond + REAL_SECOND( 10 ), "e_TestTE", -8, false );
    Log( "created " + num );

    uint duration = 0;
    uint[] values;
    if( GetTimeEvent( num, duration, values ) )
    {
        Log( "get ok+ duration " + duration );
        for( uint i = 0; i < values.length(); i++ )
            Log( i + ") " + values[ i ] );
        Log( "get ok-" );

        if( set != 0 )
        {
            values[ 0 ] = 123;
            uint value = 456;
            values.insertLast( value );
            if( SetTimeEvent( num, duration, values ) )
            {
                Log( "set ok+" );
                for( uint i = 0; i < values.length(); i++ )
                    Log( i + ") " + values[ i ] );
                Log( "set ok-" );
            }
        }
    }
}

uint e_TestTE( int[] @ values )
{
    Log( "e_TestTE+" );
    for( uint i = 0; i < values.length(); i++ )
        Log( i + ") " + values[ i ] );
    Log( "e_TestTE-" );
    return 0;
}

void DoorKey( Critter& cr, int, int, int )
{
    uint16 hx = cr.HexX, hy = cr.HexY;
    Map@   map = cr.GetMap();
    if( not valid( map ) )
        return;
    map.MoveHexByDir( hx, hy, cr.Dir, 1 );
    Item@ door = map.GetDoor( hx, hy );
    if( not valid( door ) )
        return;
    Item@ key = cr.AddItem( PID_TEMPLE_KEY, 1 );
    if( not valid( key ) )
        return;
    key.LockerId = door.LockerId;
    key.Update();
}

void HandToInv( Critter& cr, int, int, int )
{
    Item@ item = cr.GetItem( 0, SLOT_HAND1 );
    if( valid( item ) )
    {
        if( cr.MoveItem( item.Id, 0, SLOT_INV ) )
            Log( "ok" );
        else
            Log( "fail" );
    }
}

void KillSpawn( Critter& cr, int, int, int )
{
    uint16 hx = cr.HexX, hy = cr.HexY;
    Map@   map = cr.GetMap();
    if( not valid( map ) )
        return;

    map.MoveHexByDir( hx, hy, cr.Dir, 1 );

    Critter@ oldNpc = map.GetCritter( hx, hy );
    if( not valid( oldNpc ) )
        return;

    DeleteNpc( oldNpc );

    uint[] values = { map.Id, hx, hy };
    CreateTimeEvent( __FullSecond + REAL_MS( 50 ), "e_KillSpawn", values, false );
}

uint e_KillSpawn( uint[] @ values )
{
    Map@ map = GetMap( values[ 0 ] );
    if( valid( map ) )
        map.AddNpc( 20 + Random( 0, 10 ), values[ 1 ], values[ 2 ], 2, null, null, null );
    return 0;
}

void        DropDrugs( Critter& iam, int, int, int )
{
    Map@ map = iam.GetMap();
    if( not valid( map ) )
        return;

    uint16 hx = iam.HexX, hy = iam.HexY;
    for( uint i = 0; i < 10; i++ )
    {
        map.MoveHexByDir( hx, hy, iam.Dir, 1 );
        Critter@ cr = map.GetCritter( hx, hy );
        if( valid( cr ) )
        {
            DropDrugEffects( cr );
            cr.Say( SAY_NORM, "Drugs dropped." );
            break;
        }
    }
}

void ClearExplode( Critter& iam, int, int, int )
{
    Map@ map = iam.GetMap();
    if( not valid( map ) )
        return;

    Item@[] items;
    map.GetItems( PID_ACTIVE_DYNAMITE, items );
    map.GetItems( PID_ACTIVE_PLASTIC_EXPLOSIVE, items );
    map.GetItems( PID_ACTIVE_MINE, items );

    DeleteItems( items );
}

void Sandbags( Critter& iam, int lineLen, int skipLen, int stackCount )
{
    Map@ map = iam.GetMap();
    if( not valid( map ) )
        return;

    uint16 pid = PID_SANDBAG_EMPTY;
    if( stackCount != 0 )
        pid = PID_SANDBAG_1 - 1 + stackCount;

    uint16 hx = iam.HexX, hy = iam.HexY;
    for( uint i = 0; i < uint( lineLen ); i++ )
    {
        if( skipLen != 0 )
            skipLen--;
        else
        {
            map.MoveHexByDir( hx, hy, iam.Dir, 1 );
            map.AddItem( hx, hy, pid, 1 );
        }
    }
}

void ClearItems( Critter& iam, int lineLen, int skipLen, int )
{
    Map@ map = iam.GetMap();
    if( not valid( map ) )
        return;

    Item@[] items;
    uint16 hx = iam.HexX, hy = iam.HexY;
    for( uint i = 0; i < uint( lineLen ); i++ )
    {
        if( skipLen != 0 )
            skipLen--;
        else
        {
            map.MoveHexByDir( hx, hy, iam.Dir, 1 );
            map.GetItems( hx, hy, items );
        }
    }

    DeleteItems( items );
}

import void PlayMusic( Map& map, string& musicName, uint pos, uint repeat ) from "media";
void        BattleMusic( Critter& iam, int index, int, int )
{
    if( index == 1 )
        PlayMusic( iam.GetMap(), "02 - Into The Dust.ogg", 0, 0 );
    else if( index == 2 )
        PlayMusic( iam.GetMap(), "07 - Echelon.ogg", 0, 0 );
    else if( index == 3 )
        PlayMusic( iam.GetMap(), "11 - Face To Face.ogg", 0, 0 );
    else if( index == 4 )
        PlayMusic( iam.GetMap(), "16 - Stranglet.ogg", 0, 0 );
    else if( index == 5 )
        PlayMusic( iam.GetMap(), "17 - Trinity.ogg", 0, 0 );
    else
        PlayMusic( iam.GetMap(), "01 - No Fate No Fear.ogg", 0, 0 );
}

void FixPlayer( Critter& admin, int id, int, int )
{
    Critter@ cr = ::GetCritter( id );
    if( valid( cr ) )
    {
        if( cr.StatBase[ ST_BONUS_LOOK ] == 9999 )
        {
            cr.StatBase[ ST_BONUS_LOOK ] = 0;
            if( cr.Perk[ PE_SHARPSHOOTER ] != 0 )
                cr.StatBase[ ST_BONUS_LOOK ] = 6;
            admin.Say( SAY_NETMSG, "Fixed bonus look." );
        }

        if( cr.StatBase[ ST_REPLICATION_TIME ] == -1 )
        {
            cr.StatBase[ ST_REPLICATION_TIME ] = 0;
            cr.TimeoutBase[ TO_REPLICATION ] = 0;
            admin.Say( SAY_NETMSG, "Fixed replication." );
        }

        cr.SetEvent( CRITTER_EVENT_DEAD, null );
    }
    else
    {
        admin.Say( SAY_NETMSG, "Not found." );
    }
}

void SetAnim1( Critter& cr, int value, int, int )
{
    cr.SetAnims( 0, value, 0 );
}

void Pos( Critter& cr, int newPos, int, int )
{
    // 0 - stand, 1 - crouch, 2 - prone
    int curPos = ( ( cr.Anim1Life & ANIM1_CROUCH ) != 0 ? 1 : ( ( cr.Anim1Life & ANIM1_PRONE ) != 0 ? 2 : 0 ) );
    switch( curPos )
    {
    case 0:
        switch( newPos )
        {
        case 1:
            cr.Animate( 0, ANIM2_CROUCH, null, true, true );
            break;
        case 2:
            cr.Animate( 0, ANIM2_CROUCH, null, true, true );
            cr.Animate( ANIM1_CROUCH, ANIM2_PRONE, null, false, true );
            break;
        default:
            break;
        }
        break;
    case 1:
        switch( newPos )
        {
        case 0:
            cr.Animate( 0, ANIM2_STAND, null, true, true );
            break;
        case 2:
            cr.Animate( 0, ANIM2_PRONE, null, true, true );
            break;
        default:
            break;
        }
        break;
    case 2:
        switch( newPos )
        {
        case 0:
            cr.Animate( 0, ANIM2_CROUCH, null, true, true );
            cr.Animate( ANIM1_CROUCH, ANIM2_STAND, null, false, true );
            break;
        case 1:
            cr.Animate( 0, ANIM2_CROUCH, null, true, true );
            break;
        default:
            break;
        }
        break;
    default:
        break;
    }
    switch( newPos )
    {
    case 0:
        cr.SetAnims( 0, 0, 0 );
        break;
    case 1:
        cr.SetAnims( 0, ANIM1_CROUCH, 0 );
        break;
    case 2:
        cr.SetAnims( 0, ANIM1_PRONE, 0 );
        break;
    default:
        break;
    }
}

void ColorOffset( Critter& cr, int skin, int hair, int armor )
{
    cr.SetAnims( 0, ANIM1_COLOR_SKIN( skin ) | ANIM1_COLOR_HAIR( hair ) | ANIM1_COLOR_ARMOR( armor ), 0 );
}

void Shield( Critter& cr, int on, int, int )
{
    if( on != 0 )
        cr.SetAnims( 0, ANIM1_SHIELD, 0 );
    else
        cr.SetAnims( 0, 0, 0 );
}

void Palette( Critter& cr, int index, int, int )
{
    cr.SetAnims( 0, ANIM1_PALETTE( index ), 0 );
}

void SetWalk( Critter& cr, int time, int off, int )
{
    cr.StatBase[ ST_WALK_TIME ] = time;
    cr.ModeBase[ MODE_NO_WALK ] = off;
}

void SetRun( Critter& cr, int time, int off, int )
{
    cr.StatBase[ ST_RUN_TIME ] = time;
    cr.ModeBase[ MODE_NO_RUN ] = off;
}

void SetMikeWall( Critter& cr, int, int, int)
{
	cr.StatBase[ST_STRENGTH] = 5;
	cr.StatBase[ST_PERCEPTION] = 9;
	cr.StatBase[ST_CHARISMA] = 9;
	cr.StatBase[ST_ENDURANCE] = 6;
	cr.StatBase[ST_INTELLECT] = 8;
	cr.StatBase[ST_AGILITY] = 10;
	cr.StatBase[ST_LUCK] = 8;
	cr.AddItem(PID_LEATHER_ARMOR_MK_II, 1);
}

void SetScripter( Critter& cr, int, int, int)
{
	cr.StatBase[ST_STRENGTH] = 10;
	cr.StatBase[ST_PERCEPTION] = 10;
	cr.StatBase[ST_CHARISMA] = 10;
	cr.StatBase[ST_ENDURANCE] = 10;
	cr.StatBase[ST_INTELLECT] = 10;
	cr.StatBase[ST_AGILITY] = 10;
	cr.StatBase[ST_LUCK] = 10;
	cr.SkillBase[SK_SMALL_GUNS] = 300;
	cr.SkillBase[SK_ENERGY_WEAPONS] = 300;
	cr.SkillBase[SK_OUTDOORSMAN] = 300;
	cr.ModeBase[MODE_NO_LOOT] = 1;
	cr.ModeBase[MODE_NO_STEAL] = 1;
	cr.StatBase[ST_ACTION_POINTS] = 20;
	cr.StatBase[ST_RUN_TIME] = 10;
	cr.AddItem(PID_XL70E3, 1);
	cr.AddItem(PID_5MM_JHP, 1000);
	cr.AddItem(PID_STIMPAK, 20);
	cr.AddItem(PID_BLACK_ROBE, 1);
	cr.AddItem(PID_M72_GAUSS_RIFLE, 1);
	cr.AddItem(PID_2MM_EC_AMMO, 500);
}

void excep0( Critter& cr, int, int, int )
{
    Log( "excep0" );
    excep1( cr );
}
void excep1( Critter& cr )
{
    Log( "excep1" );
    int y = 100;
    excep2( 6 );
}
void excep2( int i )
{
    Log( "excep2" );
    for( int k = 0; k < 10; k++ )
        excep3();
}
void excep3()
{
    Log( "excep3" );
    int h = 0;
    int k = 10 / h;
}

void toDead( Critter& cr, int, int, int )
{
    cr.ToDead( ANIM2_DEAD_BLOODY_SINGLE, null );
}
void toLife( Critter& cr, int, int, int )
{
    cr.ToLife();
}
void toKO( Critter& cr, int, int, int )
{
    cr.ToKnockout( KNOCKOUT_ANIM2_DEFAULT( true ), 1000, cr.HexX, cr.HexY );
}

void SayAttackProtected(Critter& cr, int, int, int)
{
	Critter@[] critters;
	cr.GetMap().GetCritters(0, FIND_ALL, critters);
	for (uint i = 0; i < critters.length(); i++)
	{
		critters[i].Say(SAY_NORM_ON_HEAD, "" + GetAttackProtectionCount(critters[i]));
	}
}

void SayOffence(Critter& cr, int, int, int)
{
	Critter@[] critters;
	cr.GetMap().GetCritters(0, FIND_ALL | FIND_ONLY_PLAYERS, critters);
	for (uint i = 0; i < critters.length(); i++)
	{
		critters[i].Say(SAY_NORM_ON_HEAD, "" + GetOffenceLevel(critters[i]));
	}
}

void ClearOffences(Critter& cr, int offender, int, int)
{
	Critter@ critter = GetCritter(offender);
	if(valid(critter))
		ClearOffenceLevel(critter);
}

void animate( Critter& cr, int anim1, int anim2, int )
{
    cr.Animate( anim1, anim2, null, true, true );
}

void sendQuestMessage(Critter& cr, int, int, int)
{
	SendQuestMessage(cr, 9001102, 9001001);
}

void setDeterioriation(Critter& cr, int critterWithItems, int deterioriation, int)
{
	Critter@ critter = GetCritter(critterWithItems);
	if(!valid(critter))
		return;
		
	Item@[] items;
	critter.GetItems(0, items);
	
	for (uint i = 0; i < items.length(); i++)
	{
		if(items[i].IsDeteriorable())
		{
			items[i].Deterioration = deterioriation;
			items[i].Update();
		}
	}
}

void setBrokenCount(Critter& cr, int critterWithItems, int brokenCount, int)
{
	Critter@ critter = GetCritter(critterWithItems);
	if(!valid(critter))
		return;
		
	Item@[] items;
	critter.GetItems(0, items);
	
	for (uint i = 0; i < items.length(); i++)
	{
		if(items[i].IsDeteriorable())
		{
			items[i].Val4 = brokenCount;
			items[i].Update();
		}
	}
}

void SetTraveller(Critter& cr, int critterId, int type, int)
{
	Critter@ critter = GetCritter(critterId);
	if(!valid(critter))
		return;
		
	uint16[] locations = {LOCATION_Hub, LOCATION_Junktown};
	SetTraveller(critterId, true, 0, REAL_MINUTE(1), REAL_MINUTE(1), locations, true);
}

void AddFollower(Critter& cr, int travellerId, int playerId, int)
{
	Traveller traveller(travellerId);
	traveller.AddFollower(playerId);
}

void ViewMap(Critter& cr, int look, int hx, int hy)
{
	Map@ map = cr.GetMap();
	if(!valid(map))
		return;
	
	cr.ViewMap(map, look, hx, hy, 1);
}


/**
* Patches
*/

void PatchStartLoc(Critter& cr, int, int, int)
{
	Map @[] maps;
	GetAllMaps (MAP_Start_Location, maps);
	
	for (uint i = 0; i < maps.length(); i++)
	{
		if(!valid(maps[i]))
			continue;
		maps[i].SetScript("start_location@_StartMapInit");	
	}

}

void PatchMapInitScripts1(Critter& cr, int, int, int)
{
	uint16[] maps = {MAP_junktown, 
		MAP_hub, MAP_hub_oldtown, MAP_hub_watermerchants, MAP_hub_carstore,
		MAP_bone_adytum, MAP_bone_blades, MAP_bone_gunrunners, MAP_bone_library,
		MAP_vcity, MAP_vcity_vault_1, MAP_vcity_vault_2, MAP_vcity_vault_3};
	string[] scripts = {
		"map_junktown@_MapInit", 
		"map_hub@_MapInit", "map_hub@_MapInit", "map_hub@_MapInit", "map_hub@_MapInit", 
		"map_bone@_MapInit", "map_bone@_MapInit", "map_bone@_MapInit", "map_bone@_MapInit", 
		"map_vcity@_MapInit", "map_vcity@_MapInit", "map_vcity@_MapInit", "map_vcity@_MapInit"
	};
	
	for (uint i = 0; i < maps.length(); i++)
	{
		Map@ map = GetMapByPid(maps[i], 0);
		if(!valid(map))
			return;
			
		map.SetScript(scripts[i]);	
	}
}

void PatchNpcExp1( Critter& cr, int, int, int )
{
	uint16[] locations = {	
		LOCATION_Den,	
		LOCATION_Klamath,	
		LOCATION_Modoc,	
		LOCATION_VaultCity,	
		LOCATION_Gecko,
		LOCATION_BrokenHills,	
		LOCATION_NewReno,
		LOCATION_Sierra,
		LOCATION_NCR,
		LOCATION_Cathedral,
		LOCATION_MilitaryBase,
		LOCATION_Redding,
		LOCATION_SanFrancisco,
		//LOCATION_Navarro,
		LOCATION_Junktown,               
		LOCATION_Hub,                    
		LOCATION_Boneyard,
		LOCATION_BOS,
		LOCATION_sf_caravandepo	};
	for (uint i = 0; i < locations.length(); i++)
	{
		Location@ loc = GetLocationByPid(locations[i],0);
		Map @[] maps;
		if (!valid(loc))
			continue;
		loc.GetMaps(maps);
		for(uint j=0; j<maps.length(); j++)
		{
			if (valid (maps[j]))
			{
				Critter@[] critters;
				 maps[j].GetCritters( 0, FIND_ALL | FIND_ONLY_NPC, critters);
				for(uint x=0; x<critters.length(); x++)
				{
					critters[x].StatBase[ST_KILL_EXPERIENCE] = 0;
					//critters[x].ModeBase[MODE_NO_LOOT] = 1;
					//critters[x].ModeBase[MODE_NO_STEAL] = 1;
					//critters[x].ModeBase[MODE_NO_DROP] = 1;
				}
			}
		}
	}
}

void PatchHotelDoors( Critter& cr, int , int, int )
{
    Map@[] maps;
    ::GetAllMaps( 601, maps );
    for( uint i = 0, j = maps.length(); i < j; i++ )
    {
        if (valid(maps[i]))
        {
            Item@[] items;
            maps[i].GetItemsByType (ITEM_TYPE_DOOR, items);
            for( uint k = 0, x = items.length(); k < x; k++ )
            {
                if (items[k].GetScriptId()>0)
                {
                    if (GetScriptName(items[k].GetScriptId())=="hotel@InitRoomDoorIn")
                    {
                        items[k].SetScript( "hotel@InitRoomDoorOut" );
                    }
                }
            }
        }
    }
}

void PatchHouseDoorVals( Critter& cr, int id, int, int )
{
	Item@[] items;
	uint patchcount=0;
	uint count = ::GetAllItems( 0, items );
	for( uint i = 0; i < count; i++ )
	{
		if(items[i].GetScriptId()==uint(id) && items[i].GetType()==ITEM_TYPE_DOOR)
		{
			items[i].Val1=1;
			patchcount++;
		}
	}
	items.resize(0);
	cr.Say(SAY_NETMSG, "Doors patched "+patchcount);
}

void PatchItemValue( Critter& cr, int itemid, int ValueNum , int Value)
{
	Map@ map = cr.GetMap();
	if (!valid(map))
		return;
	Item@ item = map.GetItem( itemid );
	if (!valid(item))
		return;
	if (ValueNum>11)
		return;
	switch( ValueNum )
    {
    case 0:
        item.Val0 = Value;
        break;
    case 1:
        item.Val1 = Value;
        break;
    case 2:
        item.Val2 = Value;
        break;
    case 3:
        item.Val3 = Value;
        break;
    case 4:
        item.Val4 = Value;
        break;
    case 5:
        item.Val5 = Value;
        break;
    case 6:
        item.Val6 = Value;
        break;
	case 7:
        item.Val7 = Value;
        break;
    case 8:
        item.Val8 = Value;
        break;
    case 9:
        item.Val9 = Value;
        break;
	case 10:
		if (item.GetType()==ITEM_TYPE_DOOR)
			SETFLAG( item.LockerCondition, LOCKER_NOOPEN );
        break;
    case 11:    
        if (item.GetType()==ITEM_TYPE_CONTAINER)
			SETFLAG( item.LockerCondition, LOCKER_GUARDED ); 
        break;        
    }
	cr.Say(SAY_NETMSG, "Values set");
}


void PatchNpcHp( Critter& cr, int, int , int)
{
	Critter@[] npcs;
    GetAllNpc( 0, npcs );
	for( uint i = 0, j = npcs.length(); i < j; i++ )
    {
		Critter@ cr=npcs[i];
		if (!valid(cr))
			continue;
		int curHp = cr.StatBase[ ST_CURRENT_HP ];
		int maxHp = cr.Stat[ST_MAX_LIFE];
		if(cr.IsDead())
			cr.StatBase[ST_HEALTH_LEVEL] = -1024;
		else if(curHp == maxHp)
			cr.StatBase[ST_HEALTH_LEVEL] = 4;
		else
			cr.StatBase[ST_HEALTH_LEVEL] = (3 * curHp) / maxHp + 1;
	}
	npcs.resize(0);
}

//unprotected town
void changecolor1( Critter& cr, int pid, int, int )
{
    Location @ loc = GetLocationByPid( pid, 0 );
    if valid(loc)
    {
        loc.Color=0x703c1c07;
    }
}

//instance
void changecolor2( Critter& cr, int pid, int, int )
{
    Location @ loc = GetLocationByPid( pid, 0 );
    if valid(loc)
    {
        loc.Color=0x80755300;
    }
}

void RecolorLocations( Critter& cr, int, int, int )
{
    Location@[] locs;
    ::GetAllLocations( 0, locs );
    for( uint i = 0, j = locs.length(); i < j; i++ )
    {
        if (!valid(locs[i]))
			continue;
		
		if (locs[i].IsDungeon())
			locs[i].Color=0x80755300;
		else if (locs[i].IsTown() && !locs[i].IsGuarded())
			locs[i].Color=0x703c1c07;
		//else if (locs[i].IsBase())
		//	locs[i].Color=0x700000FF;
		//else if (locs[i].IsTent())
    }
}

void DeleteBuggedMaps( Critter& cr, int, int, int )
{
	    Location@[] locs;
    ::GetAllLocations( 0, locs );
    for( uint i = 0, j = locs.length(); i < j; i++ )
    {
		if (locs[i].IsEncounter() && locs[i].GeckCount==0)
			DeleteLocation(locs[i].Id);
	}
}


void testdialog(Critter& player, int dialognumber, int , int )
{
    Map@ map = player.GetMap();
    if (valid(map))
    {
        RunDialog (player, dialognumber, 1, 1, true);
    }
}

void massteleport(Critter& cr, int mapId, int entire, int)
{
    array<Critter@> crits;
    uint            n = cr.GetMap().GetCritters(0, FIND_ALL | FIND_ONLY_PLAYERS, crits);
    for(uint i = 0; i < n; i++)
        crits[i].TransitToMap(mapId, entire);
}

void grouptp( Critter& player, int mapId, int entire, int )
{
	Map@ map = GetMap( mapId );
	if( valid(map) )
	{
	    array<Critter@> crGroup = { player };
	    uint cLen = 1;
		cLen += player.GetFollowGroup( FIND_ALL, crGroup );

	    for( uint c=0; c<cLen; c++ )
			crGroup[c].TransitToMap( mapId, entire, true );
	}
}

void shitrain( Critter& cr, int area, int amount, int)
{
	Map@ map = cr.GetMap();
	if (!valid(map))
		return;
	uint16 hexX=cr.HexX;
	uint16 hexY=cr.HexY;
	uint shit=0;
    uint spawnamount=amount;
	for( int i = 0; i < amount; i++ )
	{
		if (shit >= spawnamount)
        {
			break;
        }
		if ( AddShit( hexX, hexY, cr.Dir, map, area) )
			shit++;
	}
}

bool AddShit( uint16 hexX, uint16 hexY, uint8 dir, Map& map, uint16 area)
{
    hexX += Random( -area , area );
    hexY += Random( -area , area );
    
	if(!GetFreeHex(map, 1,hexX, hexY))
	{
		return false;
	}
	Item@ dung = map.AddItem(hexX, hexY, Random(9303, 9306), 1);
	
	return true;
}

void getridofshit( Critter& cr, int, int, int) // Items. Not fucking players.
{
	Map@ map = cr.GetMap();
	array<Item@> shits;
	map.GetItems(9303, shits);
	map.GetItems(9304, shits);
	map.GetItems(9305, shits);
	map.GetItems(9306, shits);
	for (uint i=0 ; i<shits.length() ; i++)
	{
			DeleteItem(shits[i]);
	}
}

// Author: cvet
#include "_macros.fos"
#include "_msgstr.fos"
#include "_teams.fos"
#include "_npc_pids.fos"
#include "_animation.fos"
#include "teams_table.fos"
#include "utils_for_array.fos"

#include "logging_h.fos"
#include "utils_h.fos"
#include "mapdata_h.fos"
#include "pdata_h.fos"

#pragma bindfunc "void InitLocationEx() -> fonline_tla.dll InitLocationEx"
#pragma bindfunc "void FinishLocationEx() -> fonline_tla.dll FinishLocationEx"

// Imports
import void InitializeGame() from "config";
import bool OnUseExplode( Critter& cr, Item& explode, Critter@ targetCr, Item@ targetItem, Scenery@ targetScen, uint timer ) from "explode";
import bool UseItemOnCar( Critter& cr, Item& car, Item& item ) from "car";
import bool UseSkillOnCar( Critter& cr, Item& car, int skill, bool password ) from "car";
import void WorldmapInit() from "worldmap";
import bool Create_Start( Critter& player ) from "start_location";
import void SetReplicationTime( Critter& cr ) from "replication";
import void ReplicateCritter( Critter& cr ) from "replication";
import void CombatAttack( Critter& cr, Critter@ target, ProtoItem& weapon, uint8 weaponMode, ProtoItem@ ammo, uint16 hexX, uint16 hexY, bool is2nd ) from "combat";  // HEX_SHOOTING
import bool TryRepairItem( Critter& cr, Item& item ) from "repair";
import bool WantedSignSet( Item& wantedSign, string& name, uint cost ) from "wanted";
import bool IsReadableBook( uint16 pid ) from "books";
import void TryReadBook( Critter& cr, Item& book ) from "books";
import bool TrySetTent( Critter& cr, Item& bpack ) from "personal_tent";
import bool TrySetElock( Critter& cr, Item& elock, Item@ targetItem ) from "elock";
import void TryUseHintBook( Critter& cr, Item& hintbook ) from "experience";
import void UseDrug( Critter& cr, Item& drug ) from "drugs";
import void UseDrugOn( Critter& cr, Critter& onCr, Item& drug ) from "drugs";
import bool UseGeiger( Critter& cr, Item& geiger ) from "geiger";
import bool UseStealthBoy( Critter& cr, Item& stboy ) from "items_stealth";
import bool UseMotionSensor( Critter& cr, Item& motion ) from "items_stealth";
import bool UseItemOnGeiger( Critter& cr, Item& geiger, Item& item ) from "geiger";
import bool UseSkillOnGeiger( Critter& cr, Item& geiger, int skill ) from "geiger";
import bool AddAttackPlane( Critter& npc, uint priority, Critter& target ) from "npc_planes";
import bool AddAttackPlane( Critter& npc, uint priority, Critter& target, int minHp ) from "npc_planes";
import bool UseSkillOnLocker( Critter& cr, Item& locker, int skill, bool password ) from "lockers";
import bool PickupFurniture( Critter& cr, Item& furniture,  int skill ) from "furniture";
import bool PerkCheck( Critter& cr, uint perk ) from "perks";
import void CritterGenerate( Critter& cr ) from "parameters";
import int  GetDeteriorationProcent( Item& item ) from "repair";
import void SetDeterioration( Item& item, int deteriorationProcent, int repairPool ) from "repair";
import void NpcProcessLevel( Critter& npc ) from "parameters";
import bool IsPermanentDeath( uint id ) from "replication";
import void EditRadioSettings( Critter& player, Item& radio ) from "radio";
import void ClearAttackProtection( Critter& critter ) from "custom_data";
import bool IsProtectedFromSkill( Critter& critter, int skill, Critter@ targetCritter, Item@ targetItem, Scenery@ targetScenery ) from "custom_data";
import void ClearSkillProtection( Critter& critter ) from "custom_data";
import bool DecraftItem(Critter& cr, Item@ item) from "disassemble";
import void LoadPlayerFactionData( Critter& player ) from "faction_core";
import void SavePlayerFactionData( Critter& player ) from "faction_core";
import void StartFactions() from "faction_core";
import void ReadNews() from "news";
import void SendNews( Critter& player ) from "news";
import bool RescourceGather( Critter& cr, Scenery@ onScenery ) from "resources2";
import uint CheckPlayerName( const string& name ) from "parameters";
import void SendFactionData( Critter@ cr, int faction ) from "faction_core";
import void SendRelationsData( Critter@ cr ) from "faction_core";
import void SendFactionScore( Critter@ cr ) from "faction_core";
import void SendMessagesToClients( Critter@ cr ) from "stocmessages";
import void TcLockerInit() from "tc";
import void DeclareEvents() from "game_events";
import void CheckAllGameEvents() from "game_events";
import void UpdateBankAccountInfo( Critter& cr ) from "banks";
import void DropDrugEffects( Critter& cr ) from "drugs";
import void DropRadiation( Critter& cr ) from "radiation";
import void CheckCheatEffects( Critter& cr ) from "drugs";
import void InitQuestLocations() from "quest";
import bool CaptureBrahmin( Critter& capturer, Critter& target, bool& out sub ) from "follower_capturing";
import void ClearCharFactionInfo( Critter& cr ) from "faction_core";
import void ValidateBases( Critter& cr ) from "personal_base";
import bool critter_use_mariposa_bomb( Critter& cr, Item& item, Critter@ targetCr, Item@ targetItem, Scenery@ targetScen, uint param ) from "map_mariposa";
import void InitializeGossip() from "game_event_gossip";
import void AddOnlinePlayer( Critter& cr ) from "faction_cache";
import void DelOnlinePlayer( Critter& cr ) from "faction_cache";
import void BuildFactionCache() from "faction_cache";
import void TakeAwayCitizenship( Critter& player ) from "map_ncr";
import bool UseBp( Critter& player, Item& item ) from "blueprints";
import void InitUnlockedItems() from "blueprints";
import void ProcessLogoffPlayerInRandomDungeon( Critter& critter ) from "random_dungeon";
import void ProcessLoginPlayerInRandomDungeon( Critter& player ) from "random_dungeon";
import void HouseMapOut( Critter&, Map& ) from "house";
import void RefreshDrugTimeouts( Critter& cr ) from "drugs";
import void SetTbTimeouts( Critter& cr ) from "drugs";
import void fd_process_critter_dead( Critter& critter ) from "fraud_detector";
import void fd_process_map_critter_in( Map& map, Critter& cr ) from "fraud_detector";
import bool IsMovableContainer( Item& locker ) from "movable_container";
import bool IsFurniture( Item& item ) from "furniture";
import void TryReroll( Critter& cr ) from "reroll";
import void ValidatePlayer( Critter& cr ) from "validation";
import void AuctionSystemStart() from "auction";
import bool IsRelation( uint faction, uint faction2, int relation ) from "faction_cache";
import bool IsPrison( Map@ map ) from "replication";
import void ProcessCharControl( Critter& cr, Map& map, bool map_in ) from "charcontrol";
import void SimCheck( Critter& cr ) from "sim_scripts";

// KarmaManager karma;

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Called before world generation.
void init()
{
    InitLogs();
    InitializeGame();
    InitLocationEx();
    InitQuestLocations();
    InitUnlockedItems();
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on start server.
bool start()
{
    // Send info about others critters
    // Remember:
    // - all this info can be hacked in client;
    // - more parameters - more traffic.
    SetSendParameter( ST_GENDER, true );
    SetSendParameter( ST_AGE, true );
    SetSendParameter( ST_FOLLOW_CRIT, true );
    SetSendParameter( ST_KARMA, true );
    // Armor class, uses Agility
    SetSendParameter( ST_ARMOR_CLASS, true );
    SetSendParameter( ST_TURN_BASED_AC, true );
    // Agility
    SetSendParameter( ST_AGILITY, true );
    // Hit points, uses Strenght and Endurance
    SetSendParameter( ST_HEALTH_LEVEL, true );
    SetSendParameter( ST_MAX_LIFE, true, "fonline_tla.dll@_AllowParameterIfAwareness" );
    SetSendParameter( ST_CURRENT_HP, true, "fonline_tla.dll@_AllowParameterIfAwareness" );
    // Strenght, uses battle timeout
    SetSendParameter( ST_STRENGTH, true, "fonline_tla.dll@_AllowParameterIfAwareness" );
    SetSendParameter( PE_ADRENALINE_RUSH, true );
    // Battle timeout
    SetSendParameter( TO_BATTLE, true );
    // Endurance
    SetSendParameter( ST_ENDURANCE, true, "fonline_tla.dll@_AllowParameterIfAwareness" );
    // Injures
    SetSendParameter( DAMAGE_EYE, true );
    SetSendParameter( DAMAGE_RIGHT_ARM, true );
    SetSendParameter( DAMAGE_LEFT_ARM, true );
    SetSendParameter( DAMAGE_RIGHT_LEG, true );
    SetSendParameter( DAMAGE_LEFT_LEG, true );
    // Item slots, passed with -
    SetSendParameter( -SLOT_HAND1, true, "fonline_tla.dll@allowSlot_Hand1" );
    SetSendParameter( -SLOT_ARMOR, true );
    // Some flags for correct client working
    SetSendParameter( MODE_NO_BARTER, true );
    SetSendParameter( MODE_NO_STEAL, true );
    SetSendParameter( MODE_NO_LOOT, true );
    SetSendParameter( MODE_NO_FLATTEN, true );
    SetSendParameter( MODE_NO_TALK, true );
    SetSendParameter( MODE_BARTER_ONLY_CASH, true );
    SetSendParameter( SK_BARTER, true ); // needed for correct price calculation
    // 3d animation layers
    #ifdef PLAYERS_3D
    // Enable sending 3d layers, from Skin to Backpack
    uint fromLayer = ST_ANIM3D_LAYERS + ANIM3D_LAYER_SKIN;
    uint toLayer = ST_ANIM3D_LAYERS + ANIM3D_LAYER_BACKPACK;
    for( uint i = fromLayer; i <= toLayer; i++ )
        SetSendParameter( i, true );
    #endif
    // Npc talk distance
    SetSendParameter( ST_TALK_DISTANCE, true );
    // Dialog id
    SetSendParameter( ST_DIALOG_ID, true );
    // To see pid of unarmed attack
    SetSendParameter( ST_HANDS_ITEM_AND_MODE, true );
    // Scale factor
    SetSendParameter( ST_SCALE_FACTOR, true );
    // Walk / Run speed
    SetSendParameter( ST_WALK_TIME, true );
    SetSendParameter( ST_RUN_TIME, true );
    // PVPTEAMS
    SetSendParameter( PVPTEAM, true );
    SetSendParameter( MAIN_FACTION, true );
    // Friendly NPC's
    SetSendParameter( CR_FLAGS1, true );

    // Send item data masks
    // Look fields in fonline.h 'struct Item::ItemData'
    //               SortValue  Info Indicator    PicMapHash       PicInvHash   AnimWaitBase AStay[2] AShow[2] AHide[2]      Flags      Rate LightDist Inten Flags  LightColor    ScriptId TrapValue       Count             Cost                ScriptValues[10]                                                                                                   Other 36 bytes
    // ITEM_DATA_MASK_CHOSEN                                                                                           ITEM_DATA_MASK_CHOSEN                                                                                                ITEM_DATA_MASK_CHOSEN
    int8[] mask0 = {  -1, -1,     -1,   -1,     -1, -1, -1, -1,  -1, -1, -1, -1,    0,  0,   0,  0,   0,  0,   0,  0,   -1, -1, -1, -1,  -1,    -1,    -1,    -1,  -1, -1, -1, -1,   0, 0,     0, 0,    -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0 };
    // ITEM_DATA_MASK_CRITTER                                                                                          ITEM_DATA_MASK_CRITTER                                                                                               ITEM_DATA_MASK_CRITTER
    int8[] mask1 = {   0,  0,     -1,    0,      0,  0,  0,  0,   0,  0,  0,  0,    0,  0,   0,  0,   0,  0,   0,  0,   -1, -1, -1, -1,  -1,    -1,    -1,    -1,  -1, -1, -1, -1,   0, 0,     0, 0,     0,  0,  0,  0,   0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 0, 0 };
    // ITEM_DATA_MASK_CRITTER_EXT                                                                                      ITEM_DATA_MASK_CRITTER_EXT                                                                                           ITEM_DATA_MASK_CRITTER_EXT
    int8[] mask2 = {   0,  0,     -1,   -1,      0,  0,  0,  0,   0,  0,  0,  0,    0,  0,   0,  0,   0,  0,   0,  0,   -1, -1, -1, -1,  -1,    -1,    -1,    -1,  -1, -1, -1, -1,   0, 0,     0, 0,    -1, -1, -1, -1,   0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0 };
    // ITEM_DATA_MASK_CONTAINER                                                                                        ITEM_DATA_MASK_CONTAINER                                                                                             ITEM_DATA_MASK_CONTAINER
    int8[] mask3 = {  -1, -1,     -1,   -1,      0,  0,  0,  0,  -1, -1, -1, -1,    0,  0,   0,  0,   0,  0,   0,  0,   -1, -1, -1, -1,  -1,    -1,    -1,    -1,  -1, -1, -1, -1,   0, 0,     0, 0,    -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0 };
    // ITEM_DATA_MASK_MAP                                                                                              ITEM_DATA_MASK_MAP                                                                                                   ITEM_DATA_MASK_MAP
    int8[] mask4 = {  -1, -1,     -1,   -1,     -1, -1, -1, -1,   0,  0,  0,  0,   -1, -1,  -1, -1,  -1, -1,  -1, -1,   -1, -1, -1, -1,  -1,    -1,    -1,    -1,  -1, -1, -1, -1,   0, 0,     0, 0,     0,  0,  0,  0,   0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0 };
    SetItemDataMask( ITEM_DATA_MASK_CHOSEN, mask0 );
    SetItemDataMask( ITEM_DATA_MASK_CRITTER, mask1 );
    SetItemDataMask( ITEM_DATA_MASK_CRITTER_EXT, mask2 );
    SetItemDataMask( ITEM_DATA_MASK_CONTAINER, mask3 );
    SetItemDataMask( ITEM_DATA_MASK_MAP, mask4 );
    // Initialization npc driven faction (first time only)
    StartFactions();
    BuildFactionCache();

    // Global map initialization
    WorldmapInit();

    // Tc lockers
    TcLockerInit();

    // Events
    DeclareEvents();
    CheckAllGameEvents();
    InitializeGossip();

    // News
    ReadNews();

    // Auction
    AuctionSystemStart();

    // Cleanup Manager
    StartPersonalDataCleanup();
    CreateTimeEvent( __FullSecond + REAL_MINUTE( 15 ), "e_SendScore", 0, false );

    LoadPrisoners();
    return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on world initialization.
// Parameter         Min    Max
// multiplier        1      50000
// year              1700   30000
// month             1      12
// day               1      31
// hour              0      23
// minute            0      59
void get_start_time( uint16& multiplier, uint16& year, uint16& month, uint16& day, uint16& hour, uint16& minute )
{
    multiplier = 20;
    year = 2246;
    month = 10;
    day = 30;
    hour = 1;
    minute = 0;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on finish server.
void finish()
{
    FinishLocationEx();
    CloseLogs();
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call every returned value, in milliseconds.
// Return next call in milliseconds or zero to disable loop.
uint loop()
{
    return 0;     // Disable
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter attack another.
void critter_attack( Critter& cr, Critter& target, ProtoItem& weapon, uint8 weaponMode, ProtoItem@ ammo )
{
    // if( cr.IsPlayer() && valid( ammo ) && ammo.ProtoId == PID_EMP_ROCKET && target.Stat[ ST_BODY_TYPE ] == BT_ROBOT )
    // if (cr.IsPlayer() && target.Timeout[ TO_AGGRESSOR ] == 0)
    //	cr.TimeoutBase[ TO_AGGRESSOR ] = __FullSecond + REAL_MINUTE( 1 );
    CombatAttack( cr, target, weapon, weaponMode, ammo, 0, 0, false ); // HEX_SHOTING

    // karma.ProcessAttack(cr, target);
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter attack another.
void critter_attacked( Critter& cr, Critter& attacker )
{
    if( cr.IsPlayer() )
        return;                             // Diable player helping
    else
    {
        // Answer on attack
        if( _CritIsFromEncounter( cr ) )
        {
            cr.AddEnemyInStack( attacker.Id );
            return;
        }
        else
            AddAttackPlane( cr, 0, attacker );
    }
    // if(cr.Timeout[TO_AGGRESSOR]>0) return;

    uint helpers = 0;
    uint maxHelpers = 8;
    Critter@[] critters;
    cr.GetCritters( true, FIND_LIFE_AND_KO | FIND_ONLY_NPC, critters );
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        NpcPlane@ plane = critters[ i ].GetCurPlane();
        if( valid( plane ) && plane.Type == AI_PLANE_ATTACK && plane.Attack_TargId == attacker.Id )
        {
            helpers++;
            if( helpers >= maxHelpers )
                return;                    // No help needed
            @critters[ i ] = null;         // Exclude this critter
        }
    }

    int  crHpProc = cr.Stat[ ST_CURRENT_HP ] * 100 / cr.Stat[ ST_MAX_LIFE ];
    uint teamId = cr.Stat[ ST_TEAM_ID ];
    if( teamId == TEAM_Citizen )
        return;
    uint attackerTeamId = attacker.Stat[ ST_TEAM_ID ];
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        Critter@ someCr = critters[ i ];
        if( not valid( someCr ) )
            continue;                           // Skip excluded

        uint someCrTeamId = someCr.Stat[ ST_TEAM_ID ];
        if( attackerTeamId == someCrTeamId )
            continue;                                         // No attack temmate
        if( someCrTeamId == teamId )
        {
            AddAttackPlane( someCr, 0, attacker );
            helpers++;
            if( helpers >= maxHelpers )
                break;                                             // Enough
        }
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter steal another.
bool critter_stealing( Critter& cr, Critter& thief, Item& item, uint count )
{
    if( cr.Param[ STEAL_PROTECTED ] > 0 )
    {
        return false;
    }
    thief.TimeoutBase[ TO_AGGRESSOR ] = __FullSecond + REAL_MINUTE( 1 );
    Location@ loc = GetLocationOf( thief );
    if( valid( loc ) && loc.IsTown() && loc.IsGuarded() )
    {

        if( loc.GetProtoId() == LOCATION_NCR )
        {
            thief.SayMsg( SAY_NORM_ON_HEAD, TEXTMSG_TEXT, 70373 );
            TakeAwayCitizenship( thief );
        }
        else
            return false;
    }
    if( cr.IsDead() || cr.Timeout[ TO_BATTLE ] > 0 || thief.Timeout[ TO_BATTLE ] > 0 )
    {
        thief.StatBase[ ST_LAST_STEAL_CR_ID ] = 0;
        thief.StatBase[ ST_STEAL_COUNT ] = 0;
        return false;
    }

    if( cr.Mode[ MODE_NO_PVP ] != 0 || thief.Mode[ MODE_NO_PVP ] != 0 )
    {
        thief.Say( SAY_NETMSG, "No PvP." );
        return false;
    }

    int dir1 = cr.Dir;
    int dir2 = thief.Dir;
    int kDir = MAX( dir1, dir2 ) - MIN( dir1, dir2 );
    if( kDir > 3 )
        kDir = 6 - kDir;

    int steal = thief.Skill[ SK_STEAL ];
    if( steal <= 0 )
        steal = 1;
    int size = item.Proto.Volume;
    if( size <= 0 )
        size = 1;

    // Perk pickpocket, ignore size and facing
    if( thief.Perk[ PE_PICKPOCKET ] != 0 )
    {
        kDir = 0;
        size = 1;
    }

    // Count modifier
    int kCount = count / steal;
    if( kCount <= 0 )
        kCount = 1;

    // Check time of stealing
    uint lastStealCrId = thief.Stat[ ST_LAST_STEAL_CR_ID ];
    uint stealCount = thief.Stat[ ST_STEAL_COUNT ];
    if( lastStealCrId == cr.Id && thief.Timeout[ TO_STEALING ] > 0 )
        steal -= steal * stealCount * 9 / 100;

    // Calc
    int  k = ( steal - kDir * 10 ) / ( size * kCount );
    k = CLAMP( k, 5, 95 );
    bool success = !( Random( 1, 100 ) > k );

    if( success )
    {
        // Add experience     10,30,60,100,150,210,280,360,450,550,660,780
        const int[] stealExp = { 5, 10, 15, 20, 25, 25 };

        if( lastStealCrId == cr.Id && thief.Timeout[ TO_STEALING ] > 0 )
        {
            stealCount++;
            if( stealCount > 11 )
                stealCount = 11;
            thief.StatBase[ ST_STEAL_COUNT ] = stealCount;
        }
        else
        {
            thief.StatBase[ ST_LAST_STEAL_CR_ID ] = cr.Id;
            thief.StatBase[ ST_STEAL_COUNT ] = 0;
        }

        if( cr.Perk[ PE_THIEF ] != 0 )
            thief.TimeoutBase[ TO_STEALING ] = STEAL_TIMEOUT( thief ) - REAL_SECOND( 10 );
        else
            thief.TimeoutBase[ TO_STEALING ] = STEAL_TIMEOUT( thief );

        if( cr.IsNpc() )
        {
            GameVar@ stealExpCount = ::GetUnicumVar( UVAR_steal_exp_count, cr.Id, thief.Id );
            if( stealExpCount < 6 )
            {
                thief.StatBase[ ST_EXPERIENCE ] += stealExp[ stealCount ];
                thief.AddScore( SCORE_THIEF, 1 );
            }
            stealExpCount = stealExpCount + 1;
        }
    }
    else
    {
        thief.StatBase[ ST_LAST_STEAL_CR_ID ] = 0;
        thief.StatBase[ ST_STEAL_COUNT ] = 0;
        if( thief.Perk[ PE_THIEF ] != 0 && Random( 1, 100 ) <= cr.ParamBase[ ST_LUCK ] )
            thief.TimeoutBase[ TO_SK_STEAL ] = __FullSecond;

        if( cr.IsNpc() )
        {
            int thiefHp = thief.Stat[ ST_CURRENT_HP ];
            AddAttackPlane( cr, 0, thief, thiefHp< 10 || Random( 1, 10 ) > cr.Stat[ ST_LUCK ] + 4 || cr.Stat[ ST_CHARISMA ] < 3 ? __DeadHitPoints : Random( thiefHp / 4, thiefHp / 2 ) );
        }
    }
    // karma.ProcessStealing(thief, cr, success);

    return success;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter use item.
bool critter_use_item( Critter& cr, Item& item, Critter@ targetCr, Item@ targetItem, Scenery@ targetScen, uint param )
{
    bool   isPlayer = cr.IsPlayer();
    uint16 pid = item.GetProtoId();
    bool   useOnSelf = ( not valid( targetCr ) && not valid( targetItem ) && not valid( targetScen ) );

    /*if(valid(item) && valid(targetCr))
            karma.ProcessUseItemOnCritter(cr, item, targetCr);*/
    // Cigarettes smoking
    // Radio
    if( useOnSelf )
    {
        if( FLAG( item.Flags, ITEM_RADIO ) )
        {
            if( isPlayer )
                EditRadioSettings( cr, item );
            return true;
        }

        if( pid == PID_FALLOUT_2_HINTBOOK )
        {
            TryUseHintBook( cr, item );
            return true;
        }

        // Book reading
        if( IsReadableBook( pid ) )
        {
            TryReadBook( cr, item );
            return true;
        }
        if( pid == PID_BPACK_TENT )
        {
            TrySetTent( cr, item );
            return true;
        }
        if( item.GetType() == ITEM_TYPE_BLUEPRINT )
            return UseBp( cr, item );
    }
    if( pid == PID_ELOCK )
        return TrySetElock( cr, item, targetItem );

    // Explosion
    if( OnUseExplode( cr, item, targetCr, targetItem, targetScen, param ) )
        return true;

    // Cars
    if( valid( targetItem ) && targetItem.GetType() == ITEM_TYPE_CAR && UseItemOnCar( cr, targetItem, item ) )
        return true;

    // Drugs
    if( item.GetType() == ITEM_TYPE_DRUG )
    {
        if( useOnSelf )
            UseDrug( cr, item );
        else if( valid( targetCr ) )
            UseDrugOn( cr, targetCr, item );
        else
            cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING );
        return true;
    }

    // Play dice
    if( pid == PID_DICE )
    {
        cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_DICE_THROW, "$result" + Random( 1, 6 ) );
        return true;
    }
    if( pid == PID_LOADED_DICE )
    {
        cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_DICE_THROW, "$result" + uint( ( item.Id % 6 ) + 1 ) );
        return true;
    }

    // Magic ball
    if( pid == PID_MAGIC_8_BALL )
    {
        if( !useOnSelf )
            return false;
        uint lastStr  = 3899;
        switch( cr.Stat[ ST_LUCK ] )
        {
        case 10:
            lastStr = 3941;
            break;
        case 9:
            lastStr = 3941;
            break;
        case 8:
            lastStr = 3935;
            break;
        case 7:
            lastStr = 3932;
            break;
        case 6:
            lastStr = 3919;
            break;
        case 5:
            lastStr = 3919;
            break;
        default:
            lastStr = 3908;
            break;
        }
        lastStr = Random( 3899, lastStr );
        cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, lastStr );
        return true;
    }

    // Cosmetic
    if( pid == PID_COSMETIC_CASE && cr.Stat[ ST_GENDER ] == GENDER_FEMALE )
    {
        cr.SayMsg( SAY_EMOTE_ON_HEAD, TEXTMSG_TEXT, STR_COSMETIC_USE );
        return true;
    }
    if( ( pid == PID_STEALTH_BOY || pid == PID_ACTIVE_STEALTH_BOY ) && useOnSelf && UseStealthBoy( cr, item ) )
        return true;

    if( ( pid == PID_MOTION_SENSOR || pid == PID_ACTIVE_MOTION_SENSOR ) && useOnSelf && UseMotionSensor( cr, item ) )
        return true;

    // Geiger counter
    if( pid == PID_GEIGER_COUNTER && useOnSelf && UseGeiger( cr, item ) )
        return true;
    if( valid( targetItem ) && targetItem.GetProtoId() == PID_GEIGER_COUNTER && UseItemOnGeiger( cr, targetItem, item ) )
        return true;

    // capturing
    if( pid == PID_ROPE && valid( targetCr ) )
    {
        bool sub = false;
        if( CaptureBrahmin( cr, targetCr, sub ) )
        {
            if( sub )
                cr.DeleteItem( PID_ROPE, 1 );
            return true;
        }
    }

    if( pid == PID_FLARE && useOnSelf )
    {
        Map@ map = cr.GetMap();
        if( valid( map ) )
        {
            Location @ loc = map.GetLocation();
            if( valid( loc ) && loc.IsEncounter() && ( __FullSecond - GetRootMapData( loc, MAP_DATA_ENCOUNTER_CREATION ) < int( REAL_MINUTE( 15 ) ) ) )
            {
                cr.DeleteItem( PID_FLARE, 1 );
                Item@ flare = map.AddItem( cr.HexX, cr.HexY, PID_ACTIVE_FLARE, 1 );
                Critter@[] players;
                map.GetCritters( 0, FIND_LIFE | FIND_ONLY_PLAYERS, players );
                for( uint i = 0; i < players.length(); i++ )
                {
                    players[ i ].SayMsg( SAY_NETMSG, TEXTMSG_TEXT, 70324 );
                }
                if( loc.Visible != true )
                    loc.Visible = true;
                loc.Color = COLOR_RED;
                ;
                flare.Val2 = CreateTimeEvent( __FullSecond + REAL_MINUTE( 8 ), "e_Flare", flare.Id, true );
                return true;
            }
        }
        cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, 70332 );
        return true;
    }

    if( pid == PID_MARIPOSA_BOMB )
    {
        return critter_use_mariposa_bomb( cr, item, targetCr, targetItem, targetScen, param );
    }

    // Take process to engine
    return false;
}

uint e_Flare( uint[] @ values )
{
    for( uint i = 0; i < values.length(); i++ )
    {
        Item@ flare = GetItem( values[ i ] );
        if( valid( flare ) )
        {
            uint16 x = 0;
            uint16 y = 0;
            Map@   map = flare.GetMapPosition( x, y );
            DeleteItem( flare );
            if( valid( map ) )
            {
                Location @ loc = map.GetLocation();
                uint locPid = loc.GetProtoId();                 // get proto id of loc.
                if( ( locPid >= LOCATION_ENCOUNTERS_START ) && ( locPid <= LOCATION_ENCOUNTERS_END ) )
                {
                    Item@[] items;
                    uint nf = map.GetItems( PID_ACTIVE_FLARE, items ) - 1;
                    // Log("Checking number of flares: "+nf);
                    if( nf == 0 )
                    {
                        // Log("Setting map invisible and autogarbage");
                        Critter@[] players;
                        map.GetCritters( 0, FIND_LIFE | FIND_ONLY_PLAYERS, players );
                        for( uint i = 0; i < players.length(); i++ )
                        {
                            players[ i ].SayMsg( SAY_NETMSG, TEXTMSG_TEXT, 70325 );
                        }
                        loc.Visible = false;
                        loc.Update();
                    }
                }
            }
        }

    }
    return 0;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter use skill.
bool critter_use_skill( Critter& cr, int skill, Critter@ targetCr, Item@ targetItem, Scenery@ targetScen )
{
    // "Fix" for SetChosenActions() using special skills, each of them need to be added here to work
    if( uint( skill ) == uint16( SKILL_PICK_ON_GROUND ) )
        skill = SKILL_PICK_ON_GROUND;

    bool isPlayer = cr.IsPlayer();

    if( isPlayer && valid( targetItem ) && !IsFurniture( targetItem ) && !IsMovableContainer( targetItem ) )
    {
        if( not FLAG( targetItem.Flags, ITEM_CAN_PICKUP ) )
        {
            FLog( LOG_SUSPECT, cr.Name + " (" + cr.Id + ") access level " + cr.GetAccess() + " used skill " + skill + " on item " + targetItem.Id + " ip: " + GetIP( cr.GetIp() ) );
            if( skill == SKILL_TAKE_CONT || skill == SKILL_PUT_CONT )
                return true;
        }
    }

    if( isPlayer )
    {
        if( skill == SKILL_PUT_CONT || skill == SKILL_TAKE_CONT )
            cr.Wait( 0 );
        else if( skill == SKILL_TAKE_ALL_CONT )
        {
            cr.Wait( 0 );
            cr.StatBase[ ST_CURRENT_AP ] -= 100;
        }
    }

    if( valid( targetItem ) && targetItem.GetProtoId() == PID_CARAVAN_BOX )
    {
        DeleteItem( targetItem );
        return true;
    }

    /*if(valid(targetCr))
            karma.ProcessUseSkillOnCritter(cr, skill, targetCr);*/

    if( IsProtectedFromSkill( cr, skill, targetCr, targetItem, targetScen ) )
        return true;

    // Cars
    if( valid( targetItem ) && targetItem.GetType() == ITEM_TYPE_CAR && UseSkillOnCar( cr, targetItem, skill, false ) )
        return true;

    // Geiger counter
    if( valid( targetItem ) && targetItem.GetProtoId() == PID_GEIGER_COUNTER && UseSkillOnGeiger( cr, targetItem, skill ) )
        return true;

    // Doors or containers
    if( valid( targetItem ) && ( targetItem.GetType() == ITEM_TYPE_DOOR || targetItem.GetType() == ITEM_TYPE_CONTAINER ) && UseSkillOnLocker( cr, targetItem, skill, false ) )
        return true;

    // Furniture
    if( valid( targetItem ) && PickupFurniture( cr, targetItem, skill ) )
        return true;

    switch( skill )
    {
    case SKILL_PICK_ON_GROUND:     // Pick item or scenery on ground
    {
        // Scenery
        if( valid( targetScen ) )
        {
            if( RescourceGather( cr, targetScen ) )
                return true;
            else
            {
                cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING );
                return true;
            }
        }
        // Wanted
        if( valid( targetItem ) && targetItem.GetProtoId() == PID_WANTED_SIGN && WantedSignSet( targetItem, cr.Name, Random( 1000, 2000 ) ) )
            return true;
        // Explosion
        if( valid( targetItem ) && targetItem.GetProtoId() == PID_ACTIVE_MINE && OnUseExplode( cr, targetItem, null, null, null, 0 ) )
            return true;
        // Flare
        if( valid( targetItem ) && targetItem.GetProtoId() == PID_ACTIVE_FLARE )
        {
            if( targetItem.Val2 != 0 )
            {
                uint[] values = { targetItem.Id };
                e_Flare( values );
                EraseTimeEvent( targetItem.Val2 );
                return true;
            }
        }
        // Pick some item
        if( valid( targetItem ) )
        {
            Item@ item = targetItem;
            if( not FLAG( item.Flags, ITEM_CAN_PICKUP ) )
            {
                cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING );
                break;
            }
            if( cr.Mode[ MODE_HIDE ] != 0 && ( Random( 1, 100 ) > 30 ) )
            {
                cr.ModeBase[ MODE_HIDE ] = 0;
            }
            int freeWeight = cr.Stat[ ST_CARRY_WEIGHT ] - cr.ItemsWeight();
            if( freeWeight >= int( item.Proto.Weight * item.GetCount() ) )
            {
                // Pick full
                MoveItem( item, 0, cr );
            }
            else
            {
                // Pick half
                if( item.IsStackable() && freeWeight >= int(item.Proto.Weight) )
                    MoveItem( item, freeWeight / item.Proto.Weight, cr );
                // Overweight
                else
                    cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_OVERWEIGHT );
            }
        }
    }
    break;
    case SKILL_PUT_CONT:      // Put item in container, only targetItem is valid
    case SKILL_TAKE_CONT:     // Take item from container, only targetItem is valid
        if( cr.Mode[ MODE_HIDE ] != 0 && ( Random( 1, 100 ) > 30 ) )
            cr.ModeBase[ MODE_HIDE ] = 0;
        return false;
    case SKILL_TAKE_ALL_CONT: // Take all items from critter or item container
        if( cr.Mode[ MODE_HIDE ] != 0 )
            cr.ModeBase[ MODE_HIDE ] = 0;
        return false;         // Allow transactions
    case SKILL_LOOT_CRITTER:  // Loot critter, only targetCr is valid
        if( IsGecko( targetCr ) && cr.Perk[ PE_GECKO_SKINNING ] != 0 )
            ShowGeckoPelt( targetCr );
        cr.Action( ACTION_PICK_CRITTER, 0, null );
        cr.ShowContainer( targetCr, null, TRANSFER_CRIT_LOOT );
        return true;
    case SKILL_PUSH_CRITTER:     // Push critter, only targetCr is valid
        cr.Action( ACTION_PICK_CRITTER, 2, null );
        if( ( cr.Timeout[ TO_BATTLE ] == 0 && targetCr.Timeout[ TO_BATTLE ] == 0 ) &&
            ( targetCr.IsPlayer() || ( targetCr.IsNoPlanes() && targetCr.GetTalkedPlayers( null ) == 0 ) ) )
            targetCr.MoveRandom();
        return true;
    case SK_SCIENCE:
    {
        // Radio
        if( valid( targetItem ) && FLAG( targetItem.Flags, ITEM_RADIO ) && targetItem.Accessory == ACCESSORY_CRITTER && targetItem.CritId == cr.Id )
        {
            if( isPlayer )
                EditRadioSettings( cr, targetItem );
            return true;
        }
        if( valid( targetItem ) && ( ( targetItem.Accessory == ACCESSORY_CRITTER  && targetItem.CritId == cr.Id ) || targetItem.Accessory == ACCESSORY_HEX ) ) // Disassembling from inventory and ground
        {
            if( cr.IsLife() && !cr.IsKnockout() )                                                                                                              // If in normal state
            {
                if( cr.Timeout[ TO_SK_SCIENCE ] == 0 )                                                                                                         // If no CD
                {
                    if( DecraftItem( cr, targetItem ) )
                        return true;                                                                                                                           // If we can disassemble this
                }
                else
                {
                    cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SKILL_WEARINESS );                     // Tired
                    return true;
                }
            }
        }
        cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING );             // "That does nothing"
    }
    break;
    case SK_REPAIR:
    {
        // Generic repair
        if( valid( targetItem ) && targetItem.Accessory == ACCESSORY_CRITTER  && targetItem.IsDeteriorable() && TryRepairItem( cr, targetItem ) )
            return true;
        else if( !valid( targetItem ) )
        {
            if( not valid( targetCr ) )
                @targetCr = cr;

            if( targetCr.Id == cr.Id || SAME_FACTION( cr, targetCr ) )
            {
                Item@ armor = targetCr.GetItem( 0, SLOT_ARMOR );
                if( valid( armor ) && armor.Accessory == ACCESSORY_CRITTER  && armor.IsDeteriorable() && TryRepairItem( cr, armor ) )
                    return true;
            }
        }
        cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING );
    }
    break;
    case SK_SNEAK:
    {
        if( cr.Mode[ MODE_HIDE ] != 0 )
            cr.ModeBase[ MODE_HIDE ] = 0;
        else if( not isPlayer )
            cr.ModeBase[ MODE_HIDE ] = 1;
        else
        {
            Critter@[] critters;
            if( IS_TURN_BASED_TIMEOUT( cr ) )
                cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_TIMEOUT_BATTLE_WAIT );
            else if( cr.GetCritters( true, FIND_LIFE | FIND_ONLY_PLAYERS, critters ) > 0 )
            {
                bool tosneak = true;
                for( uint i = 0; i < critters.length(); i++ )
                {
                    if( not ( SAME_FACTION( cr, critters[ i ] ) || critters[ i ].Param[ VISION_LEVEL ] > 1 || IsRelation( cr.FACTION, critters[ i ].FACTION, 1 ) ) )
                    {
                        cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SKILL_SNEAK_VISIBLE );
                        tosneak = false;
                        break;
                    }

                }
                if( tosneak )
                    cr.ModeBase[ MODE_HIDE ] = 1;
            }
            else
                cr.ModeBase[ MODE_HIDE ] = 1;
        }
    }
    break;
    case SK_STEAL:
    {
        if( valid( targetItem ) )
        {
            cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING );
        }
        else if( valid( targetCr ) && valid( cr.GetMap() ) )
        {
            // Loot
            if( targetCr.IsDead() )
            {
                cr.Action( ACTION_PICK_CRITTER, 0, null );
                cr.ShowContainer( targetCr, null, TRANSFER_CRIT_LOOT );
            }
            else if( targetCr.IsKnockout() )
            {
                cr.Action( ACTION_PICK_CRITTER, 0, null );
                cr.ShowContainer( targetCr, null, TRANSFER_CRIT_LOOT );
            }
            // Steal
            else
            {
                if( isPlayer && cr.Timeout[ TO_SK_STEAL ] > 0 )
                    cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SKILL_WEARINESS );
                else
                {
                    cr.Action( ACTION_PICK_CRITTER, 1, null );
                    cr.ShowContainer( targetCr, null, TRANSFER_CRIT_STEAL );
                    if( cr.Perk[ PE_THIEF ] != 0 )
                        cr.TimeoutBase[ TO_SK_STEAL ] = STEAL_TIMEOUT( cr ) - REAL_SECOND( 10 );
                    else
                        cr.TimeoutBase[ TO_SK_STEAL ] = STEAL_TIMEOUT( cr );
                    cr.StatBase[ ST_LAST_STEAL_CR_ID ] = 0;
                    cr.StatBase[ ST_STEAL_COUNT ] = 0;
                }
            }
        }
        else
        {
            cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING );
        }
    }
    break;
    case SK_FIRST_AID:
    {
        if( valid( targetItem ) || valid( targetScen ) )
        {
            cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING );
            break;
        }

        if( not valid( targetCr ) )
            @targetCr = cr;
        bool is_self = ( targetCr.Id == cr.Id );
        bool is_tb = false;
        if( targetCr.IsDead() )
        {
            cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SKILL_NORESSURECT );
            break;
        }

        if( targetCr.Stat[ ST_CURRENT_HP ] >= targetCr.Stat[ ST_MAX_LIFE ] )
        {
            if( _CritIsInjured( targetCr ) )
                cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SKILL_NOFIRSTAID_NEEDDOCTOR );
            else if( is_self )
                cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SKILL_NONEED_FIRSTAID );
            break;
        }

        if( isPlayer && cr.Timeout[ TO_SK_FIRST_AID ] > 0 )
        {
            cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SKILL_WEARINESS );
            break;
        }
        /*
           if( is_self && cr.Timeout[ TO_BATTLE ] > 0)
           {
                cr.SayMsg(SAY_NETMSG, TEXTMSG_TEXT, STR_SKILL_CANT_SELF_IN_CMBT);
                break;
           }
         */
        if( valid( cr.GetMap() ) && cr.GetMap().IsTurnBased() )
        {
            if( cr.Stat[ ST_ACTION_POINTS ] - __TbApCostUseSkill != cr.Stat[ ST_CURRENT_AP ]  )
            {
                cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, 70344 );
                break;
            }
            cr.StatBase[ ST_CURRENT_AP ] = 0;
            is_tb = true;
        }
        int   sk = cr.Skill[ SK_FIRST_AID ];
        uint8 mode = 0;
        if( HasItemInHands( cr, PID_FIRST_AID_KIT ) )
        {
            sk += 25;
            if( Random( 0, 30 ) == 0 )
                cr.DeleteItem( PID_FIRST_AID_KIT, 1 );
        }
        else if( HasItemInHands( cr, PID_FIELD_MEDIC_KIT ) )
        {
            sk += 50;
            if( Random( 0, 30 ) == 0 )
                cr.DeleteItem( PID_FIELD_MEDIC_KIT, 1 );
        }
        int heal = sk;
        if( heal < 1 )
            heal = 1;
        if( is_self )
        {
            if( cr.Timeout[ TO_BATTLE ] > 0 )
                heal = CLAMP( heal, 1, cr.Perk[ PE_IMPLANT_MEDIC ] != 0 ? int(175) : int(150) );
            cr.Action( ACTION_USE_SKILL, 0, null );            // test fix for no anim when fa self
        }
        else
        {
            if( cr.Timeout[ TO_BATTLE ] > 0 )
                heal = CLAMP( heal, 1, cr.Perk[ PE_IMPLANT_MEDIC ] != 0 ? int(250) : int(225) );
        }

        heal += cr.Perk[ PE_HEALER ] * 10;
        int curHp = targetCr.Stat[ ST_CURRENT_HP ];
        int maxHp = targetCr.Stat[ ST_MAX_LIFE ];
        if( curHp + heal > maxHp )
            heal = maxHp - curHp;
        targetCr.StatBase[ ST_CURRENT_HP ] += heal;
        SendHpInfo( cr, heal );
        cr.Say( SAY_NETMSG, "+" + heal );
        if( not is_self )
            targetCr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, 70374, "$name" + cr.Name + "$heal" + heal );

        // if( isPlayer )
        // {
        GameVar@ firstAidCount = ::GetUnicumVar( UVAR_first_aid_count, cr.Id, targetCr.Id );
        if( firstAidCount < __FullSecond )
        {
            if( isPlayer )
                cr.StatBase[ ST_EXPERIENCE ] += heal * 3;
            /*if(!is_self)
                                    karma.ProcessHeal(cr, targetCr, heal);*/
            firstAidCount = __FullSecond + REAL_MINUTE( 30 );
        }
        if( !is_tb )
        {
            if( cr.Perk[ PE_MEDIC ] != 0 )
                cr.TimeoutBase[ TO_SK_FIRST_AID ] = FIRST_AID_TIMEOUT_PE_MEDIC( cr );
            else
                cr.TimeoutBase[ TO_SK_FIRST_AID ] = FIRST_AID_TIMEOUT( cr );
        }
        cr.AddScore( SCORE_DOCTOR, 1 );
        // }
    }
    break;
    case SK_DOCTOR:
    {
        if( valid( targetItem ) || valid( targetScen ) )
        {
            cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING );
            break;
        }

        if( not valid( targetCr ) )
            @targetCr = cr;
        bool is_self = ( targetCr.Id == cr.Id );
        bool is_tb = false;
        if( targetCr.IsDead() )
        {
            cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SKILL_NORESSURECT );
            break;
        }

        if( not _CritIsInjured( targetCr ) && ( not targetCr.IsKnockout() || targetCr.Stat[ ST_CURRENT_HP ] < 1 ) )
        {
            if( targetCr.Stat[ ST_CURRENT_HP ] < targetCr.Stat[ ST_MAX_LIFE ] )
                cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SKILL_NODOCTOR_NEEDFIRSTAID );
            else if( is_self )
                cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SKILL_NONEED_DOCTOR );
            break;
        }

        if( isPlayer && cr.Timeout[ TO_SK_DOCTOR ] > 0 )
        {
            cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SKILL_WEARINESS );
            break;
        }

        if( valid( cr.GetMap() ) && cr.GetMap().IsTurnBased() )
        {
            if( !HasItemsInHands( cr, PID_DOCTORS_BAG, PID_PARAMEDICS_BAG ) )
            {
                cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, 70350 );
                break;
            }
            if( cr.Stat[ ST_ACTION_POINTS ] - __TbApCostUseSkill != cr.Stat[ ST_CURRENT_AP ]  )
            {
                cr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, 70344 );
                break;
            }
            cr.StatBase[ ST_CURRENT_AP ] = 0;
            is_tb = true;
        }

        int uninjured = 0;
        int sk = cr.Skill[ SK_DOCTOR ];
        if( HasItemInHands( cr, PID_DOCTORS_BAG ) )
        {
            sk += 25;
            if( Random( 0, 30 ) == 0 )
                cr.DeleteItem( PID_DOCTORS_BAG, 1 );
        }
        else if( HasItemInHands( cr, PID_PARAMEDICS_BAG ) )
        {
            sk += 50;
            if( Random( 0, 30 ) == 0 )
                cr.DeleteItem( PID_PARAMEDICS_BAG, 1 );
        }

        if( targetCr.Stat[ ST_CURRENT_HP ] > 0 && targetCr.IsKnockout() && targetCr.Stat[ ST_CURRENT_AP ] < 0 && sk > Random( 5, 195 ) )
        {
            targetCr.ToLife();
            targetCr.StatBase[ ST_CURRENT_AP ] = 0;
            targetCr.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, 70375, "$name" + cr.Name );
        }

        for( int i = DAMAGE_EYE; i <= DAMAGE_LEFT_LEG; ++i )
        {
            if( targetCr.Damage[ i ] != 0 )
            {
                if( sk > Random( 5, 95 ) )
                {
                    targetCr.DamageBase[ i ] = 0;
                    cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SKILL_HEAL_DMG( i - DAMAGE_POISONED ) );
                    if( i == DAMAGE_EYE )
                        targetCr.RefreshVisible();
                    uninjured++;
                }
                else
                {
                    cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SKILL_NOHEAL_DMG( i - DAMAGE_POISONED ) );
                }
                sk /= 2;
            }
        }

        if( isPlayer )
        {
            if( uninjured > 0 )
                cr.StatBase[ ST_EXPERIENCE ] += uninjured * 50;
            if( !is_tb )
            {
                if( cr.Perk[ PE_MEDIC ] != 0 )
                    cr.TimeoutBase[ TO_SK_DOCTOR ] = DOCTOR_TIMEOUT_PE_MEDIC( cr );
                else
                    cr.TimeoutBase[ TO_SK_DOCTOR ] = DOCTOR_TIMEOUT( cr );
            }
            cr.AddScore( SCORE_DOCTOR, uninjured );
        }
    }
    break;
    case SK_LOCKPICK:
    {
        // Lockers processed in lockers.fos
    }
    break;
    case SK_TRAPS:
    {
        // Explosion
        if( valid( targetItem ) )
        {
            uint16 pid = targetItem.GetProtoId();
            if( ( pid == PID_ACTIVE_DYNAMITE || pid == PID_ACTIVE_PLASTIC_EXPLOSIVE || pid == PID_ACTIVE_MINE ) &&
                OnUseExplode( cr, targetItem, null, null, null, 0 ) )
                return true;
        }

        cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING );
    }
    break;
    default:
    {
        cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_USE_NOTHING );
    }
    break;
    }

    return true;
}

bool IsGecko( Critter& critter )
{
    return critter.GetProtoId() == NPC_PID_GoldenGecko ||
           critter.GetProtoId() == NPC_PID_ToughGoldenGecko ||
           critter.GetProtoId() == NPC_PID_FireGecko ||
           critter.GetProtoId() == NPC_PID_ToughFireGecko ||
           critter.GetProtoId() == NPC_PID_SmallSilverGecko ||
           critter.GetProtoId() == NPC_PID_ToughSilverGecko ||
           critter.GetProtoId() == NPC_PID_ToxicGecko ||
           critter.GetProtoId() == NPC_PID_MatureToxicGecko;

}

void ShowGeckoPelt( Critter& gecko )
{
    uint16[] geckoPeltsPids = { PID_GECKO_PELT, PID_GOLDEN_GECKO_PELT, PID_FIRE_GECKO_PELT, PID_TOXIC_GECKO_PELT };
    Item@[] items;
    gecko.GetItems( -1, items );
    for( uint i = 0; i < items.length(); i++ )
        if( _ItemIsNoLoot( items[ i ] ) &&  geckoPeltsPids.find( items[ i ].GetProtoId() ) >= 0 )
            _ItemUnsetNoLoot( items[ i ] );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter reload weapon.
// If ammo is not valid than only unload.
void critter_reload_weapon( Critter& cr, Item& weapon, Item@ ammo )
{
    // Special weapons
    if( weapon.Proto.Weapon_Caliber == 0 )
    {
        if( weapon.GetProtoId() == PID_SOLAR_SCORCHER )
        {
            if( IS_NIGHT( __Hour ) )
                cr.SayMsg( SAY_NETMSG, TEXTMSG_GAME, STR_SOLAR_SCORCHER_NO_LIGHT );
            else
            {
                weapon.AmmoCount = weapon.Proto.Weapon_MaxAmmoCount;
                if( cr.Param[ MODE_LAST_WPN_MODE ] != 0 )
                {
                    weapon.SetMode( cr.Param[ MODE_LAST_WPN_MODE ] );
                    cr.ParamBase[ MODE_LAST_WPN_MODE ] = 0;
                }
                weapon.Update();
            }
        }

        return;
    }

    // Other weapons
    // Unload
    if( not valid( ammo ) || ( weapon.AmmoCount > 0 && weapon.AmmoPid != ammo.GetProtoId() ) )
    {
        if( weapon.AmmoPid != 0 )
        {
            Item@ existAmmo = cr.GetItem( weapon.AmmoPid, -1 );
            if( not valid( existAmmo ) )
                cr.AddItem( weapon.AmmoPid, weapon.AmmoCount );
            else
                _IncItem( existAmmo, weapon.AmmoCount );
        }
        weapon.AmmoCount = 0;
    }

    // Load
    if( valid( ammo ) )
    {
        uint count = MIN( ammo.GetCount(), weapon.Proto.Weapon_MaxAmmoCount - weapon.AmmoCount );
        weapon.AmmoCount += count;
        weapon.AmmoPid = ammo.GetProtoId();
        _SubItem( ammo, count );
        if( cr.Param[ MODE_LAST_WPN_MODE ] != 0 )
        {
            weapon.SetMode( cr.Param[ MODE_LAST_WPN_MODE ] );
            cr.ParamBase[ MODE_LAST_WPN_MODE ] = 0;
        }
    }

    weapon.Update();
}
// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on player register/login in game or npc created/loaded.
// Default start position for players is center of global map.
void critter_init( Critter& cr, bool firstTime )
{
    if( firstTime )
    {
        if( cr.IsPlayer() )
        {
            bool regexploit = false;

            int[] skipParams;
            for( uint i = ST_STRENGTH; i <= ST_LUCK; i++ )
                skipParams.insertLast( i );
            for( uint i = TAG_SKILL1; i <= TAG_SKILL3; i++ )
                skipParams.insertLast( i );
            for( uint i = TRAIT_BEGIN; i <= TRAIT_END; i++ )
                skipParams.insertLast( i );
            skipParams.insertLast( ST_AGE );
            skipParams.insertLast( ST_GENDER );

            for( uint i = 0; i < 1000; i++ )
            {
                if( skipParams.find( i ) == -1 && cr.ParamBase[ i ] != 0 )
                {
                    Log( "REGISTRATION PARAM " + i + " FOR CHAR " + cr.Name + " (" + cr.Id + ") IS NOT OK AND =" + cr.Param[ i ] );
                    cr.ParamBase[ i ] = 0;
                    regexploit = true;
                }
            }
            if( regexploit )
                FLog( LOG_GM, cr.Name + " (" + cr.Id + ") with access level " + cr.GetAccess() + " POSSIBLE REG ABUSE from ip: " + GetIP( cr.GetIp() ) );
            // Input: 7 special, 3 tag skills, 2 traits, age, gender
            uint traits = 0;
            for( uint i = TRAIT_BEGIN; i <= TRAIT_END; i++ )
            {
                if( cr.TraitBase[ i ] != 0 && traits < 2 )
                {
                    cr.TraitBase[ i ] = 1;
                    traits++;
                }
                else
                    cr.TraitBase[ i ] = 0;
            }

            if( cr.StatBase[ ST_GENDER ] < 0 || cr.StatBase[ ST_GENDER ] > 1 )
                cr.StatBase[ ST_GENDER ] = 0;
            if( cr.StatBase[ ST_AGE ] < 14 || cr.StatBase[ ST_AGE ] > 80 )
                cr.StatBase[ ST_AGE ] = 25;
            for( uint i = ST_STRENGTH; i <= ST_LUCK; i++ )
                cr.StatBase[ i ] = CLAMP( cr.StatBase[ i ], 1, 10 );

            if( ( cr.StatBase[ ST_STRENGTH ] + cr.StatBase[ ST_PERCEPTION ] + cr.StatBase[ ST_ENDURANCE ] +
                  cr.StatBase[ ST_CHARISMA ] + cr.StatBase[ ST_INTELLECT ] + cr.StatBase[ ST_AGILITY ] + cr.StatBase[ ST_LUCK ] ) != __StartSpecialPoints )
            {
                for( uint i = ST_STRENGTH; i <= ST_LUCK; i++ )
                    cr.StatBase[ i ] = 5;
            }

            cr.StatBase[ ST_EMP_RESIST ] = 500;
            // cr.AddHolodiskInfo( 42 );           // Journalist's research

            // Default skin
            #ifdef PLAYERS_3D
            if( cr.StatBase[ ST_GENDER ] == GENDER_MALE )
            {
                cr.StatBase[ ST_BASE_CRTYPE ] = CLAMP( cr.StatBase[ ST_BASE_CRTYPE ], CRTYPE_3D_MALE_NORMAL, CRTYPE_3D_MALE_FAT );
                cr.StatBase[ ST_ANIM3D_LAYERS + ANIM3D_LAYER_HAIR ] = CLAMP( cr.StatBase[ ST_ANIM3D_LAYERS + ANIM3D_LAYER_HAIR ], 0, ATTRIBUTE_Hair_Male_Shoulder + ATTRIBUTE_COLOR_RedGrey );
                if( cr.StatBase[ ST_ANIM3D_LAYERS + ANIM3D_LAYER_MUSTACHE ] != ATTRIBUTE_Mustache_MadMax )
                    cr.StatBase[ ST_ANIM3D_LAYERS + ANIM3D_LAYER_MUSTACHE ] = CLAMP( cr.StatBase[ ST_ANIM3D_LAYERS + ANIM3D_LAYER_MUSTACHE ], 0, ATTRIBUTE_Mustache_Male_Stubble + ATTRIBUTE_COLOR_RedGrey );
                cr.StatBase[ ST_ANIM3D_LAYERS + ANIM3D_LAYER_BEARD ] = CLAMP( cr.StatBase[ ST_ANIM3D_LAYERS + ANIM3D_LAYER_BEARD ], 0, ATTRIBUTE_Beard_Male_Stubble + ATTRIBUTE_COLOR_RedGrey );
            }
            else
            {
                cr.StatBase[ ST_BASE_CRTYPE ] = CLAMP( cr.StatBase[ ST_BASE_CRTYPE ], CRTYPE_3D_FEMALE_NORMAL, CRTYPE_3D_FEMALE_FAT );
                cr.StatBase[ ST_ANIM3D_LAYERS + ANIM3D_LAYER_HAIR ] = CLAMP( cr.StatBase[ ST_ANIM3D_LAYERS + ANIM3D_LAYER_HAIR ], 0, ATTRIBUTE_Hair_Female_Short + ATTRIBUTE_COLOR_RedGrey );
                if( cr.StatBase[ ST_ANIM3D_LAYERS + ANIM3D_LAYER_MUSTACHE ] != ATTRIBUTE_Mustache_MadMax )
                    cr.StatBase[ ST_ANIM3D_LAYERS + ANIM3D_LAYER_MUSTACHE ] = 0;
                cr.StatBase[ ST_ANIM3D_LAYERS + ANIM3D_LAYER_BEARD ] = 0;
            }

            cr.StatBase[ ST_ANIM3D_LAYERS + ANIM3D_LAYER_SKIN ] = CLAMP( cr.StatBase[ ST_ANIM3D_LAYERS + ANIM3D_LAYER_SKIN ], ATTRIBUTE_Skin_Human_White01, ATTRIBUTE_Skin_Human_Yellow03 );
            cr.StatBase[ ST_ANIM3D_LAYERS + ANIM3D_LAYER_PONYTAIL ] = CLAMP( cr.StatBase[ ST_ANIM3D_LAYERS + ANIM3D_LAYER_PONYTAIL ], 0, ATTRIBUTE_Ponytail_Ponytail2 + ATTRIBUTE_COLOR_RedGrey );
            cr.StatBase[ ST_ANIM3D_LAYERS + ANIM3D_LAYER_ARMLET ] = ATTRIBUTE_Armlet_PipBoyClosed;

            cr.ChangeCrType( cr.StatBase[ ST_BASE_CRTYPE ] );
            #endif
            #ifndef PLAYERS_3D
            cr.ChangeCrType( cr.Stat[ ST_GENDER ] == GENDER_MALE ? CRTYPE_DEFAULT_M : CRTYPE_DEFAULT_F );
            #endif
        }

        if( cr.TagSkill[ TAG_SKILL1 ] < int(SKILL_BEGIN) || cr.TagSkill[ TAG_SKILL1 ] > int(SKILL_END) )
            cr.TagSkillBase[ TAG_SKILL1 ] = 0;
        if( cr.TagSkill[ TAG_SKILL2 ] < int(SKILL_BEGIN) || cr.TagSkill[ TAG_SKILL2 ] > int(SKILL_END) )
            cr.TagSkillBase[ TAG_SKILL2 ] = 0;
        if( cr.TagSkill[ TAG_SKILL3 ] < int(SKILL_BEGIN) || cr.TagSkill[ TAG_SKILL3 ] > int(SKILL_END) )
            cr.TagSkillBase[ TAG_SKILL3 ] = 0;
        if( cr.TagSkill[ TAG_SKILL1 ] == cr.TagSkill[ TAG_SKILL2 ] )
            cr.TagSkillBase[ TAG_SKILL1 ] = 0;
        if( cr.TagSkill[ TAG_SKILL2 ] == cr.TagSkill[ TAG_SKILL3 ] )
            cr.TagSkillBase[ TAG_SKILL2 ] = 0;
        if( cr.TagSkill[ TAG_SKILL3 ] == cr.TagSkill[ TAG_SKILL1 ] )
            cr.TagSkillBase[ TAG_SKILL3 ] = 0;

        CritterGenerate( cr );
        cr.StatBase[ ST_CURRENT_HP ] = cr.Stat[ ST_MAX_LIFE ];
        cr.StatBase[ ST_CURRENT_AP ] = cr.Stat[ ST_ACTION_POINTS ] * 100;

        // for(int i=REPUTATION_BEGIN;i<=599;i++) cr.ParamBase[i]=int(0x80000000); // 599 is last number processed in client

        if( cr.IsPlayer() )
        {
            for( uint i = ST_STRENGTH; i <= ST_LUCK; i++ )
                cr.StatBase[ i ] = CLAMP( cr.StatBase[ i ], 1, 10 );

            cr.StatBase[ ST_REPLICATION_COST ] = 0;
            cr.StatBase[ ST_REPLICATION_MONEY ] = 0;
            cr.StatBase[ ST_REPLICATION_COUNT ] = 0;
            cr.StatBase[ ST_TEAM_ID ] = 1;
            cr.StatBase[ ST_DAMAGE_TYPE ] = DAMAGE_NORMAL;
            cr.ParamBase[ CRAFT ] = 1;
            cr.ParamBase[ PATCH1 ] = 1;
            FLog( LOG_REG, "Registered player: " + cr.Name + " (" + cr.Id + ") access level " + cr.GetAccess() + " from ip: " + GetIP( cr.GetIp() ) );
        }
        else
        {
            cr.ChangeCrType( cr.StatBase[ ST_BASE_CRTYPE ] );
            if( cr.Stat[ ST_LEVEL ] != 0 )
                NpcProcessLevel( cr );
        }
    }
    else
    {
        if( valid( cr ) )
        {
            if( cr.IsPlayer() )
            {
                Patch( cr );
                if( cr.ParamBase[ MAIN_FACTION ] == 0 )           // paranoya
                    cr.ParamBase[ MAIN_FACTION_RANK ] = 0;
                LoadPlayerFactionData( cr );
                CreateTimeEvent( __FullSecond + REAL_SECOND( 4 ), "e_DelayedSMToClient", cr.Id, false );
                CreateTimeEvent( __FullSecond + REAL_SECOND( 5 ), "e_DelayedSendFD", cr.Id, false );
                CreateTimeEvent( __FullSecond + REAL_SECOND( 6 ), "e_DelayedSendRD", cr.Id, false );
                CreateTimeEvent( __FullSecond + REAL_SECOND( 7 ), "e_DelayedSendScore", cr.Id, false );
                GameVar @ var_login = GetLocalVar( LVAR_login, cr.Id );              // get local var
                if( var_login.GetValue() == 0 )
                {
                    Create_Start( cr );
                    var_login = 1;
                }
				SimCheck( cr );
                ValidateBases( cr );
                SendNews( cr );
                UpdateBankAccountInfo( cr );
                CrSpeedCalc( cr );
                ProcessLoginPlayerInRandomDungeon( cr );
                FLog( LOG_LOGIN, "Logged in player: " + cr.Name + " (" + cr.Id + ") access level " + cr.GetAccess() + " from ip: " + GetIP( cr.GetIp() ) );
            }
        }

        // Current skin validation
        Item@ armor = cr.GetItem( 0, SLOT_ARMOR );
        if( not valid( armor ) )
        {
            uint crType = cr.Stat[ ST_BASE_CRTYPE ];
            if( crType == 0 )
                crType = ( cr.Stat[ ST_GENDER ] == GENDER_MALE ? CRTYPE_DEFAULT_M : CRTYPE_DEFAULT_F );
            if( cr.CrType != crType )
                cr.ChangeCrType( crType );
        }

        // Armor perk validation
        if( not valid( armor ) && cr.Stat[ ST_CURRENT_ARMOR_PERK ] != 0 )
        {
            switch( cr.Stat[ ST_CURRENT_ARMOR_PERK ] )
            {
            case ARMOR_PERK_POWERED:
                cr.StatBase[ ST_STRENGTH_EXT ] -= 3;
                cr.StatBase[ ST_RADIATION_RESISTANCE_EXT ] -= 30;
                cr.StatBase[ ST_POWER_ARMOR_PERK ] = 0;
                break;
            case ARMOR_PERK_COMBAT:
                cr.StatBase[ ST_RADIATION_RESISTANCE_EXT ] -= 20;
                break;
            case ARMOR_PERK_ADVANCED_I:
                cr.StatBase[ ST_STRENGTH_EXT ] -= 4;
                cr.StatBase[ ST_RADIATION_RESISTANCE_EXT ] -= 60;
                cr.StatBase[ ST_POWER_ARMOR_PERK ] = 0;
                break;
            case ARMOR_PERK_ADVANCED_II:
                cr.StatBase[ ST_STRENGTH_EXT ] -= 4;
                cr.StatBase[ ST_RADIATION_RESISTANCE_EXT ] -= 75;
                cr.StatBase[ ST_POWER_ARMOR_PERK ] = 0;
                break;
            case ARMOR_PERK_HIDDEN:                     // No player name
                UNSETFLAG( cr.ParamBase[ CR_FLAGS1 ], CR_NO_NAME );
                break;
            case ARMOR_PERK_CHARISMA:
                cr.StatBase[ ST_CHARISMA_EXT ] -= 1;
                break;
            default:
                break;
            }
            cr.StatBase[ ST_CURRENT_ARMOR_PERK ] = 0;
        }

        // Clear timeouts if too long (happens when saves got removed)
        for( uint i = TIMEOUT_BEGIN; i <= TIMEOUT_END; i++ )
            if( i != TO_BATTLE && cr.Timeout[ i ] > int(MAXIMUM_TIMEOUT) )
                cr.TimeoutBase[ i ] = __FullSecond;
        cr.TimeoutBase[ TO_SPAWN_TIMEOUT ] = __FullSecond;
        // Erase zero time events
        cr.EraseTimeEvents( 0 );

        // TRAIT_FAST_SHOT migration, delete in future
        if( cr.Trait[ TRAIT_FAST_SHOT ] != 0 )
            cr.ModeBase[ MODE_NO_AIM ] = 1;
    }
    if( cr.IsPlayer() )
    {
        AddOnlinePlayer( cr );
        ValidatePlayer( cr );
        CheckBan( cr );
    }
    else
    {
        if( firstTime )
        {
            Location@ loc = GetLocationOf( cr );
            if( !valid( loc ) )
                return;
            if( loc.IsQuest() && !ItemsIsSafe( cr ) && !IsGecko( cr ) )
            {
                cr.SetBagRefreshTime( ( uint( -1 ) ) );
            }
            else if( loc.GetProtoId() == LOCATION_MilitaryBase || loc.GetProtoId() == LOCATION_Glow || loc.GetProtoId() == LOCATION_Ares )
            {
                cr.ModeBase[ MODE_NO_LOOT ] = 1;
                cr.ModeBase[ MODE_NO_DROP ] = 1;
                cr.ModeBase[ MODE_NO_STEAL ] = 1;
                cr.ModeBase[ MODE_NO_LOOSE_LIMBS ] = 1;
                cr.ModeBase[ MODE_UNLIMITED_AMMO ] = 1;
            }
            else if( loc.GetProtoId() == LOCATION_Necropolis )
                cr.ModeBase[ MODE_UNLIMITED_AMMO ] = 1;
        }
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on critter exit from game.
void critter_finish( Critter& cr, bool toDelete )
{
    if( cr.IsPlayer() )
    {
        ProcessLogoffPlayerInRandomDungeon( cr );
        DelOnlinePlayer( cr );
        FLog( LOG_LOGOFF, "Logged off player: " + cr.Name + " (" + cr.Id + ") from ip: " + GetIP( cr.GetIp() ) );
        ClearAttackProtection( cr );
        ClearSkillProtection( cr );
        if( toDelete )
        {
            ClearCharFactionInfo( cr );
            GameVar @ start_location = GetLocalVar( LVAR_start_location, cr.Id );
            Location@ loc = GetLocation( start_location.GetValue() );
            if( valid( loc ) && loc.IsTent() )
            {
                if( loc.GetProtoId() == 251 )
                {
                    int caveid = GetRootMapData( loc, MAP_DATA_START_LOC_CHILD );
                    if( caveid > 0 )
                    {
                        Location@ caveloc = GetLocation( caveid );
                        if( valid( caveloc ) && caveloc.GetProtoId() == 252 )
                            DeleteLocation( caveloc.Id );
                    }
                }
                DeleteLocation( loc.Id );
            }
        }
        else
        {
            cr.StatBase[ ST_SEQUENCE_2 ] = 0;
            cr.StatBase[ ST_TB_DONE ] = 0;
            SavePlayerFactionData( cr );
        }
    }

    if( toDelete )     // no IsPlayer() check, in case of future fancy features
    {
        array< uint > delLocs;
        uint          delLocsCount = 0, delLocsReal = 0;

        delLocsCount += GetPersonalDataList( cr, "tents", delLocs );
        delLocsCount += GetPersonalDataList( cr, "quests", delLocs );

        for( uint l = 0; l < delLocsCount; l++ )
        {
            uint locId = delLocs[ l ];

            // don't list dummy locations in summary
            Location@ loc = GetLocation( locId );
            if( !valid( loc ) || loc.IsNotValid )
                continue;

            array< Critter@ > players;
            uint              pLen = GetLocationCritters( loc, FIND_ALL | FIND_ONLY_PLAYERS, players );
            for( uint p = 0; p < pLen; p++ )
            {
                if( players[ p ].Id == cr.Id )
                    continue;

                players[ p ].SayMsg( SAY_NETMSG, TEXTMSG_TEXT, STR_LOCATION_GARBAGED_DELETESELF );

                // kicking dead players to worldmap is meh
                if( players[ p ].IsDead() )
                {
                    players[ p ].TimeoutBase[ TO_REPLICATION ] = 0;
                    ReplicateCritter( players[ p ] );
                }
            }

            DeleteLocation( locId );
            delLocsReal++;
        }

        if( delLocsReal > 0 )
            Log( "Deleted " + delLocsReal + " location" + ( delLocsReal > 1 ? "s" : "" ) + ", owner<" + cr.Name + ">" );
    }

    if( toDelete )
    {
        RemoveDeadBlocker( cr );
    }

    if( toDelete && cr.IsPlayer() )
    {
        TryReroll( cr );
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call every __CritterIdleTick time.
void critter_idle( Critter& cr )
{
    if( cr.IsDead() && cr.Timeout[ TO_REPLICATION ] == 0 )
    {
        ReplicateCritter( cr );
        return;
    }

    // Healing
    if( cr.Timeout[ TO_HEALING ] == 0 )
    {
        if( !cr.IsDead() && cr.Mode[ MODE_NO_HEAL ] == 0 && cr.StatBase[ ST_CURRENT_HP ] < cr.Stat[ ST_MAX_LIFE ] )
        {
            if( valid( cr.GetMap() ) && cr.GetMap().IsTurnBased() )
                return;

            if( cr.Stat[ ST_HEALING_RATE ] > 0 )
                cr.StatBase[ ST_CURRENT_HP ] += MAX( cr.Stat[ ST_HEALING_RATE ] * cr.Stat[ ST_MAX_LIFE ] / 300, 1 );
            else
                cr.StatBase[ ST_CURRENT_HP ] += cr.Stat[ ST_HEALING_RATE ];
            if( cr.StatBase[ ST_CURRENT_HP ] > cr.Stat[ ST_MAX_LIFE ] )
                cr.StatBase[ ST_CURRENT_HP ] = cr.Stat[ ST_MAX_LIFE ];
        }

        cr.TimeoutBase[ TO_HEALING ] = __FullSecond + HEALING_TIMEOUT( cr );
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter dies.
// Killer can be null.
void critter_dead( Critter& cr, Critter@ killer )
{
    Map@ map = cr.GetMap();


    // Move inventory items to ground
    if( ( cr.Anim2Dead == ANIM2_DEAD_PULSE_DUST || cr.Anim2Dead == ANIM2_DEAD_EXPLODE ) && _CritCanDropItemsOnDead( cr ) && !IsGuardedTownMap( map ) )
    {
        // Drop all, exclude armor
        Item@[] items;
        cr.GetItems( SLOT_INV, items );
        cr.GetItems( SLOT_HAND1, items );
        cr.GetItems( SLOT_HAND2, items );
        if( valid( map ) )
        {
            // Disable drop of hidden items
            CheckForbiddenItems( items, true );
            MoveItems( items, map, cr.HexX, cr.HexY );
        }
        else
            DeleteItems( items );
    }
    // Hide locations opened by radio
    if( cr.IsPlayer() )
    {
        if( valid( map ) )
        {
            HouseMapOut( cr, map );
            Location @ loc = map.GetLocation();             // get location id
            if( valid( loc ) && loc.IsEncounter() )
            {

                if( cr.IsKnownLoc( true, loc.Id ) )
                {
                    bool IsCar = false;
                    for( uint i = 0, l = loc.GetMapCount(); i < l; i++ )
                    {
                        Map@ m = loc.GetMapByIndex( i );
                        if( valid( m ) && map.GetItemsByType( ITEM_TYPE_CAR, null ) > 0 )
                        {
                            IsCar = true;
                            break;
                        }
                    }
                    if( !IsCar )
                        cr.UnsetKnownLoc( true, loc.Id );
                    else if( map.GetCritters( 0, FIND_LIFE_AND_KO | FIND_ONLY_PLAYERS, null ) > 0 )
                        cr.UnsetKnownLoc( true, loc.Id );
                }
            }
        }
    }




    // Mob drops


    uint16 npcPid = cr.GetProtoId();
    uint16 dropPid = 0;
    bool   noLoot = false;
    if( valid( map ) && cr.IsNpc() )
    {
        Location @ location = map.GetLocation();
        uint locPid = location.GetProtoId();
        if( valid( location ) && ( location.AutoGarbage || ( ( locPid >= LOCATION_ENCOUNTERS_START ) && ( locPid <= LOCATION_ENCOUNTERS_END ) ) ) || location.IsQuest() )
        {
            switch( npcPid )
            {
            case NPC_PID_GoldenGecko:
            case NPC_PID_ToughGoldenGecko:
                dropPid = PID_GOLDEN_GECKO_PELT;
                noLoot = true;
                break;
            case NPC_PID_SmallSilverGecko:
            case NPC_PID_ToughSilverGecko:
                dropPid = PID_GECKO_PELT;
                noLoot = true;
                break;
            case NPC_PID_SmallRadscorpion:
            case NPC_PID_SmallRadscorpion2:
            case NPC_PID_LargeRadscorpion:
            case NPC_PID_LargeRadscorpion2:
            case NPC_PID_LargeRadscorpion3:
                dropPid = PID_SCORPION_TAIL;
                break;
            case NPC_PID_Brahmin:
                dropPid = PID_BRAHMIN_SKIN;
                break;
            case NPC_PID_Brahmin2:
                dropPid = PID_BRAHMIN_SKIN;
                break;
            case NPC_PID_Brahmin3:
                dropPid = PID_BRAHMIN_SKIN;
                break;
            case NPC_PID_WeakBrahmin:
                dropPid = PID_BRAHMIN_SKIN;
                break;
            case NPC_PID_WildBrahmin:
                dropPid = PID_BRAHMIN_SKIN;
                break;
            case NPC_PID_GiantBeetle:
            case NPC_PID_GiantBeetle_2:
                if( Random( 1, 3 ) == 3 )
                    dropPid = PID_RADSCORPION_PARTS;
                break;
            case NPC_PID_FireGecko:
            case NPC_PID_ToughFireGecko:
                dropPid = PID_FIRE_GECKO_PELT;
                noLoot = true;
                break;
                // case NPC_PID_ToxicGecko:
                // case NPC_PID_MatureToxicGecko:
                //    dropPid = PID_TOXIC_GECKO_PELT;
                //    noLoot = true;
                //    break;
            }
            if( npcPid == NPC_PID_MatureToxicGecko )
            {
                dropPid = PID_TOXIC_GECKO_PELT;
                noLoot = true;
            }
        }
    }

    if( dropPid != 0 && _CritCountItem( cr, dropPid ) == 0 )
    {
        Item@ item = _CritAddItem( cr, dropPid, 1 );
        if( valid( item ) && noLoot )
            _ItemSetNoLoot( item );
    }

    // Karma, temporary
    if( valid( killer ) && killer.IsPlayer() )
    {}

    SetReplicationTime( cr );
    if( cr.IsNpc() )
        cr.DropPlanes();                // Delete all planes
    if( valid( map ) && cr.Mode[ MODE_NO_FLATTEN ] != 0 )
    {
        Item@ blocker = map.AddItem( cr.HexX, cr.HexY, PID_UNVISIBLE_BLOCK, 1 );
        if( valid( blocker ) )
            cr.StatBase[ ST_DEAD_BLOCKER_ID ] = blocker.Id;
    }

    fd_process_critter_dead( cr );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter reswapned.
void critter_respawn( Critter& cr )
{
    RemoveDeadBlocker( cr );
}

void RemoveDeadBlocker( Critter& cr )
{
    if( cr.Stat[ ST_DEAD_BLOCKER_ID ] != 0 )
    {
        Item@ block = ::GetItem( cr.Stat[ ST_DEAD_BLOCKER_ID ] );
        if( valid( block ) )
        {
            MoveItem( block, 1, cr );
            DeleteItem( block );
        }
        cr.StatBase[ ST_DEAD_BLOCKER_ID ] = 0;
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter in to map.
void map_critter_in( Map& map, Critter& cr )
{
    if( cr.IsPlayer() )
    {
        ProcessCharControl( cr, map, true );
        if( map.IsTurnBased() )
        {
            if( !IS_TURN_BASED_TIMEOUT( cr ) ) // Fix to tb combat timeout
                cr.TimeoutBase[ TO_BATTLE ] = __FullSecond + 100000000;

            cr.StatBase[ ST_CURRENT_AP ] = 0;  // Remove ap when enter tb to avoid use hex attack or hotkeys

            array< Critter@ > players;
            map.GetCritters( 0, FIND_ALL  | FIND_ONLY_PLAYERS, players );
            int               MaxSequence = 0;
            for( uint i = 0; i < players.length(); i++ )
            {
                if( players[ i ].Stat[ ST_TB_DONE ] != 0 )
                    players[ i ].StatBase[ ST_SEQUENCE_2 ] += 1;
                else if( players[ i ].Stat[ ST_SEQUENCE_2 ] > MaxSequence )
                    MaxSequence = players[ i ].Stat[ ST_SEQUENCE_2 ];
            }

            cr.StatBase[ ST_SEQUENCE_2 ] = MaxSequence + 1;
            SetTbTimeouts( cr );

        }
        else
        {
            Location@ loc = map.GetLocation();
            if( !loc.IsQuest() && !loc.IsBase() && !loc.IsTent() && !loc.IsGuarded() && !loc.IsRespawn() )
            {
                cr.ParamBase[ TO_SPAWN_TIMEOUT ] = __FullSecond + REAL_SECOND( 1 );
                CreateTimeEvent( __FullSecond + REAL_SECOND( 1 ), "e_refresh_fov", cr.Id, true );

                Item@ blocker = map.AddItem( cr.HexX, cr.HexY, PID_UNVISIBLE_BLOCK, 1 );
                if( valid( blocker ) )
                {
                    GameVar@ spawn_blocker = GetLocalVar( LVAR_spawn_blocker, cr.Id );
                    spawn_blocker = blocker.Id;
                }
            }
        }
		SimCheck( cr );

        cr.ParamBase[ STEAL_PROTECTED ] = 0;
        cr.ParamBase[ WORLDX ] = cr.WorldX;
        cr.ParamBase[ WORLDY ] = cr.WorldY;
        FLog( LOG_MAPCHANGE, cr.Name + " (" + cr.Id + ") ac lvl " + cr.GetAccess() + " enter map " + map.Id );
    }

    fd_process_map_critter_in( map, cr );
}

uint e_refresh_fov( uint[] @ values )
{
    Critter@ cr = GetCritter( values[ 0 ] );
    GameVar@ spawn_blocker = GetLocalVar( LVAR_spawn_blocker, values[ 0 ] );
    if( valid( spawn_blocker ) )
    {
        Item@ block = ::GetItem( spawn_blocker.GetValue() );
        if( valid( block ) )
            DeleteItem( block );

        spawn_blocker = 0;
    }
    if( valid( cr ) && cr.IsPlayer() )
    {
        if( cr.Param[ TO_SPAWN_TIMEOUT ] == 0 )
        {
            cr.RefreshVisible();
            return 0;
        }
        Log( "Desync" );
        return 5;
    }
    return 0;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something critter out from map.
void map_critter_out( Map& map, Critter& cr )
{
    ClearAttackProtection( cr );
    ClearSkillProtection( cr );
    cr.StatBase[ ST_SEQUENCE_2 ] = 0;
    cr.StatBase[ ST_TB_DONE ] = 0;
    cr.TimeoutBase[ TO_BATTLE ] = __FullSecond;
    if( cr.IsPlayer() )
    {
        ProcessCharControl( cr, map, false );
        FLog( LOG_MAPCHANGE, cr.Name + " (" + cr.Id + ") ac lvl " + cr.GetAccess() + " exit map " + map.Id );
		SimCheck( cr );
    }
    if( map.IsTurnBased() )
        RefreshDrugTimeouts( cr );
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something player votes for another.
// Already checked valid positions and timeout.
void karma_voting( Critter& crFrom, Critter& crTo, bool valUp )
{
    if( ( valid( crFrom ) ) && ( valid( crTo ) ) )
    {
        string name = crTo.Name;
        int    color;
        if( valUp )
            color = 1;
        else
            color = 2;
        crFrom.RunClientScript( "name_colorizing@AddCritter", color, crTo.Id, 0, name, null );
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call to determine visibility of critters.
// To start working set flag LOOK_CHECK_SCRIPT to __LookChecks global var.
// Return true to allow see one critter another, false to disallow.
// Note: CRITTER_EVENT_SHOW_CRITTER_X, CRITTER_EVENT_HIDE_CRITTER_X is not processed.
bool check_look( Map& map, Critter& cr, Critter& opponent )
{
    return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call to determine visibility of items with ITEM_TRAP flag.
// To start working set flag LOOK_CHECK_SCRIPT to __LookChecks global var.
bool check_trap_look( Map& map, Critter& cr, Item& trap )
{
    return true;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call to determine cost of single item.
// To allow function set __CustomItemCost to true.
// Don't forgot specify this function in client script.
uint item_cost( Item& item, Critter& cr, Critter& npc, bool sell )
{
    // using function in barter.fos
    return sell ? 1 : 2;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on barter transaction.
// Return false to cancel transaction.
bool items_barter( Item@[]& saleItems, uint[]& saleItemsCount, Item@[]& buyItems, uint[]& buyItemsCount, Critter& player, Critter& npc )
{
    // using function in barter.fos
    return false;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Call on something player craft some items.
// Resources have None accessory and will be deleted after this function if no will be added to some place.
void items_crafted( Item@[]& items, uint[]& itemsCount, Item@[]& resources, Critter& crafter )
{
    // Find max deterioration value
    int maxDeterioration = 0;
    int maxBrokenCounts = 0;
    for( uint i = 0, j = resources.length(); i < j; i++ )
    {
        Item@ item = resources[ i ];
        int   deterioration = GetDeteriorationProcent( item );
        if( deterioration > maxDeterioration )
            maxDeterioration = deterioration;
        if( item.IsDeteriorable() )
        {
            if( item.BrokenCount > maxBrokenCounts )
                maxBrokenCounts = item.BrokenCount;
        }
    }
    for( uint i = 0, j = items.length(); i < j; i++ )
    {
        // Unload weapons
        Item@ item = items[ i ];
        if( item.GetType() == ITEM_TYPE_WEAPON && item.Proto.Weapon_MaxAmmoCount > 0 )
        {
            item.AmmoCount = 0;
            item.Update();
        }

        // Set max deterioration value
        SetDeterioration( item, maxDeterioration, 100 - maxBrokenCounts );
    }
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Levelup callback.
void player_levelup( Critter& player, uint skillIndex, uint skillUp, uint perkIndex )
{
    if( skillIndex >= SKILL_BEGIN && skillIndex <= SKILL_END )
    {
        for( ; skillUp != 0; skillUp-- )
        {
            int skillVal = player.SkillBase[ skillIndex ];
            if( skillVal >= MAX_SKILL_VAL )
                break;

            int needPoints = 1;
            if( skillVal > __SkillModAdd6 )
                needPoints = 6;
            else if( skillVal > __SkillModAdd5 )
                needPoints = 5;
            else if( skillVal > __SkillModAdd4 )
                needPoints = 4;
            else if( skillVal > __SkillModAdd3 )
                needPoints = 3;
            else if( skillVal > __SkillModAdd2 )
                needPoints = 2;

            if( player.StatBase[ ST_UNSPENT_SKILL_POINTS ] < needPoints )
                break;
            if( skillIndex == SK_BARTER )
            {
                player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, 70338 );
                break;
            }
            if( skillIndex == SK_SCAVENGING )
            {
                player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, 70339 );
                break;
            }
            if( skillIndex == SK_UNARMED && skillVal >= 200 )
            {
                player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, 70376 );
                break;
            }
            if( skillIndex == SK_OUTDOORSMAN && skillVal >= 100 )
            {
                player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, 70377 );
                break;
            }
            if( skillIndex == SK_REPAIR && skillVal >= 200 )
            {
                player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, 70378 );
                break;
            }
            if( skillIndex == SK_SCIENCE && skillVal >= 200 )
            {
                player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, 70379 );
                break;
            }
            skillVal++;
            if( _CritIsTagSkill( player, skillIndex ) && skillVal < MAX_SKILL_VAL )
                skillVal++;
            player.SkillBase[ skillIndex ] = skillVal;
            player.StatBase[ ST_UNSPENT_SKILL_POINTS ] -= needPoints;
        }
    }
    else if( perkIndex >= PERK_BEGIN && perkIndex <= PERK_END )
    {
        if( PerkCheck( player, perkIndex ) )
        {
            player.PerkBase[ perkIndex ]++;
            player.StatBase[ ST_UNSPENT_PERKS ]--;
        }
    }

    // player.StatBase[ ST_REPLICATION_COST ] = player.Stat[ ST_LEVEL ] * 100;
}

// //////////////////////////////////////////////////////////////////////////////////////////////////
// Turn based callbacks.
// Called on every round begin, return false to disable turn-based
void turn_based_begin( Map& map )
{
    SetWalkRunTimeForNpcs( map, 100 );
    // Try end battle
    if( map.TurnBasedRound > 0 )
    {
        uint[] crittersIds;
        map.GetTurnBasedSequence( crittersIds );

        bool continueBattle = false;
        if( crittersIds.length() >= 2 )
        {
            for( uint i = 0, j = crittersIds.length(); i < j; i++ )
            {
                Critter@ cr = ::GetCritter( crittersIds[ i ] );
                if( !( not valid( cr ) || cr.IsDead() ||
                       ( cr.IsNpc() && cr.GetPlanes( AI_PLANE_ATTACK, null ) == 0 ) ||
                       ( cr.IsPlayer() && ( cr.Mode[ MODE_END_COMBAT ] != 0 || cr.Stat[ ST_CURRENT_HP ] < 1 ) ) ) )
                {
                    continueBattle = true;
                    break;
                }
            }
        }

        if( not continueBattle )
            map.EndTurnBased();
    }
    else
    {
        SetTbTimeouts( map );
        uint[] crittersIds;
        map.GetTurnBasedSequence( crittersIds );
        if( crittersIds.length() > 0 )
        {
            Critter@ cr = ::GetCritter( crittersIds[ 0 ] );
            if( valid( cr ) && cr.IsPlayer() )
                cr.StatBase[ ST_SEQUENCE_2 ] = 1;
        }
    }
}

// Call on end turn-based battle
void turn_based_end( Map& map )
{
    SetWalkRunTimeForNpcs( map, 0 );
    ResetTbEffects( map );
}

void ResetTbEffects( Map& map )
{
    array< Critter@ > players;
    map.GetCritters( 0, FIND_ALL  | FIND_ONLY_PLAYERS, players );
    for( uint i = 0; i < players.length(); i++ )
    {
        players[ i ].StatBase[ ST_SEQUENCE_2 ] = 0;
        players[ i ].StatBase[ ST_TB_DONE ] = 0;
        RefreshDrugTimeouts( players[ i ] );
    }
}

void SetTbTimeouts( Map& map )
{
    Critter@[] players;
    map.GetCritters( 0, FIND_ALL  | FIND_ONLY_PLAYERS, players );
    for( uint i = 0; i < players.length(); i++ )
        SetTbTimeouts( players[ i ] );
}

void SetWalkRunTimeForNpcs( Map& map, uint time )
{
    Critter@[] critters;
    map.GetCritters( 0, FIND_ONLY_NPC | FIND_LIFE_AND_KO, critters );

    for( uint i = 0; i < critters.length(); i++ )
    {
        if( valid( critters[ i ] ) )
        {
            critters[ i ].StatBase[ ST_WALK_TIME ] = time;
            critters[ i ].StatBase[ ST_RUN_TIME ] = time;
        }
    }
}

// Call on every begin and end turn
void turn_based_process( Map& map, Critter& cr, bool beginTurn )
{
    if( beginTurn )
    {
        if( cr.IsPlayer() )
            cr.RunClientScript( "sounds@PlayLocalSound", 0, 0, 0, "ICOMBAT2.ACM", null );

        cr.StatBase[ ST_MOVE_AP ] = cr.Stat[ ST_MAX_MOVE_AP ];
        cr.StatBase[ ST_TURN_BASED_AC ] = 0;

        if( !IS_TURN_BASED_TIMEOUT( cr ) )
            cr.TimeoutBase[ TO_BATTLE ] = __FullSecond + 100000000;         // setting to initial value (TB_BATTLE_TIMEOUT in fonline.h)

        if( cr.IsPlayer() && _CritIsOffline( cr ) )
            _EndTurn( cr );
    }
    else
    {
        if( cr.IsPlayer() )
            cr.RunClientScript( "sounds@PlayLocalSound", 0, 0, 0, "ICOMBAT1.ACM", null );
        bool hthEvade = false;
        if( cr.Perk[ PE_HTH_EVADE ] != 0 )
        {
            // In hands only HtH weapons
            Item@ hand1 = cr.GetItem( 0, SLOT_HAND1 );
            Item@ hand2 = cr.GetItem( 0, SLOT_HAND2 );
            if( ( not valid( hand1 ) || hand1.GetType() != ITEM_TYPE_WEAPON || not hand1.Weapon_IsHtHAttack( 0 ) ) &&
                ( not valid( hand1 ) || hand1.GetType() != ITEM_TYPE_WEAPON || not hand1.Weapon_IsHtHAttack( 0 ) ) )
            {
                hthEvade = true;
            }
        }

        cr.StatBase[ ST_CURRENT_AP ] += cr.Stat[ ST_CURRENT_AP_EXT ] * 100;
        cr.StatBase[ ST_CURRENT_AP_EXT ] = 0;
        cr.StatBase[ ST_TURN_BASED_AC ] = cr.Stat[ ST_CURRENT_AP ] * ( hthEvade ? 2 : 1 );
        if( cr.Stat[ ST_TURN_BASED_AC ] < 0 )
            cr.StatBase[ ST_TURN_BASED_AC ] = 0;
        if( hthEvade && cr.Skill[ SK_UNARMED ] > 0 )
            cr.StatBase[ ST_TURN_BASED_AC ] += cr.Skill[ SK_UNARMED ] / 12;
        cr.StatBase[ ST_MOVE_AP ] = 0;
        if( cr.IsPlayer() && _CritIsOffline( cr ) )
            cr.ModeBase[ MODE_END_COMBAT ] = 1;
    }
}

// Call when need generate turns sequence
void turn_based_sequence( Map& map, Critter@[]& critters, Critter@ firstTurnCrit )
{
    // Check first turn critter
    if( valid( firstTurnCrit ) && ( firstTurnCrit.IsDead() || firstTurnCrit.Stat[ ST_CURRENT_AP ] <= 0 ) )
        @firstTurnCrit = null;

    // Collect critters
    SequenceCritter[] sequenceCritters;
    for( uint i = 0, j = critters.length(); i < j; i++ )
    {
        Critter@ cr = critters[ i ];
        if( cr.Stat[ ST_SEQUENCE_2 ] != 0 )
            cr.StatBase[ ST_TB_DONE ] = 1;
        if( valid( firstTurnCrit ) && firstTurnCrit.Id == cr.Id )
            continue;
        if( cr.IsDead() )
            continue;
        sequenceCritters.resize( sequenceCritters.length() + 1 );
        @sequenceCritters.last().critter = cr;
    }

    // Sort sequence, see SequenceCritter::opCmp below
    SequenceCritterRandom = Random( 0, 1 );
    sequenceCritters.sortDesc();

    // Fill result
    critters.resize( 0 );
    if( valid( firstTurnCrit ) )
        critters.insertLast( firstTurnCrit );
    for( uint i = 0, j = sequenceCritters.length(); i < j; i++ )
        critters.insertLast( sequenceCritters[ i ].critter );
}

// Sequence sorter for turn_based_sequence
int   SequenceCritterRandom = 0;
class SequenceCritter
{
    Critter@ critter;
    int opCmp( SequenceCritter& in other )
    {
        bool     result;
        Critter@ cr1 = critter;
        Critter@ cr2 = other.critter;
        if( cr1.Stat[ ST_SEQUENCE_2 ] != cr2.Stat[ ST_SEQUENCE_2 ] )
        {
            if( cr1.Stat[ ST_SEQUENCE_2 ] == 0 )
                return int(-1);
            if( cr2.Stat[ ST_SEQUENCE_2 ] == 0 )
                return int(1);
            result = cr1.Stat[ ST_SEQUENCE_2 ] < cr2.Stat[ ST_SEQUENCE_2 ];
            return result ? int(1) : int(-1);
        }
        int seq1 = cr1.Stat[ ST_SEQUENCE ];
        int seq2 = cr2.Stat[ ST_SEQUENCE ];
        if( seq1 == seq2 )
        {
            int ag1 = cr1.Stat[ ST_AGILITY ];
            int ag2 = cr2.Stat[ ST_AGILITY ];
            if( ag1 == ag2 )
            {
                int lk1 = cr1.Stat[ ST_LUCK ];
                int lk2 = cr2.Stat[ ST_LUCK ];
                if( lk1 == lk2 )
                {
                    if( SequenceCritterRandom == 0 )
                        result = cr1.Id > cr2.Id;
                    else
                        result = cr1.Id < cr2.Id;
                }
                else
                    result = lk1 > lk2;
            }
            else
                result = ag1 > ag2;
        }
        else
            result = seq1 > seq2;
        return result ? int(1) : int(-1);
    }
}

// Call on world saving
// Range of currentIndex: 1..9999
void world_save( uint currentIndex, uint[]& deleteIndexes )
{
    // Keep only current and four last saves
    if( currentIndex == 1 )
    {
        deleteIndexes.resize( 10 );
        for( uint i = 0; i < 10; i++ )
            deleteIndexes[ i ] = 9999 - i;
    }
    else if( currentIndex > 9 )
    {
        deleteIndexes.resize( 1 );
        deleteIndexes[ 0 ] = currentIndex - 10;
    }
    // bboards
    // SaveMessengerData();
}

// Call on player try register
// Return true to allow, false to disallow
bool player_registration( uint ip, string& name, uint& textMsg, uint& strNum )
{
    uint nameError = CheckPlayerName( name );
    if( nameError != 0 )
    {
        textMsg = TEXTMSG_GAME;
        strNum = nameError;
        return false;
    }
    return true;
}

// Call on player try login
// Return true to allow, false to disallow
bool player_login( uint ip, string& name, uint id, uint& textMsg, uint& strNum )
{
    Critter @ player = GetCritter( id );
    if( valid( player ) )
    {
        // Player is online and the IP is the same, try disconnect the player to solve "character already in game"
        if( _CritIsOnline( player ) && player.GetIp() == ip )
        {
            player.SayMsg( SAY_NETMSG, TEXTMSG_TEXT, 401 );
            player.Disconnect();
            textMsg = TEXTMSG_TEXT;
            strNum = 400;
            return false;
        }

        GameVar @ var_login = GetLocalVar( LVAR_login, id );      // get local var
        if( var_login.GetValue() == 0 )
        {
            Create_Start( player );
            var_login = 1;
        }
        CreateTimeEvent( __FullSecond + REAL_SECOND( 2 ), "e_DelayedSMToClient", player.Id, false );
        CreateTimeEvent( __FullSecond + REAL_SECOND( 3 ), "e_DelayedSendFD", player.Id, false );
        CreateTimeEvent( __FullSecond + REAL_SECOND( 4 ), "e_DelayedSendRD", player.Id, false );
        CreateTimeEvent( __FullSecond + REAL_SECOND( 5 ), "e_DelayedSendScore", player.Id, false );
        SendNews( player );
    }
    return true;
}

// Call on player try change access
// Return true to allow, false to disallow
bool player_getaccess( Critter& player, int access, string& password )
{
    Log( "Access changed for player " + player.Name + ", from " + player.GetAccess() + " to " + access + "." );
    FLog( LOG_GETACCESS, "Access changed for player " + player.Name + " (" + player.Id + ") from " + player.GetAccess() + " to " + access + ". from ip: " + GetIP( player.GetIp() ) );
    return true;
}

bool player_allowcommand( Critter@ player, string@ adminPanel, uint8 command )
{
    if( valid( adminPanel ) )
    {
        if( valid( player ) )
            FLog( LOG_GM, player.Name + " (" + player.Id + ") with access level " + player.GetAccess() + " USED SERVER ADMIN PANEL from ip: " + GetIP( player.GetIp() ) );
        else
            FLog( LOG_GM, "UNKNOWN USED SERVER ADMIN PANEL" );
        return false;
    }

    if( valid( player ) )
        FLog( LOG_SUSPECT, player.Name + " (" + player.Id + ") with access level " + player.GetAccess() + " try to execute command " + command + " from ip: " + GetIP( player.GetIp() ) );

    switch( command )
    {
    // ACCESS_CLIENT
    case COMMAND_CHANGE_PASSWORD:
    case COMMAND_DELETE_ACCOUNT:
    case COMMAND_EXIT:
    case COMMAND_GETACCESS:
    case COMMAND_MYINFO:
        return true;
    // ACCESS_TESTER
    case COMMAND_DROP_UID:
    case COMMAND_PARAM:
    case COMMAND_TOGLOBAL:
        if( player.GetAccess() >= ACCESS_TESTER )
        {
            FLog( LOG_GM, player.Name + " (" + player.Id + ") with access level " + player.GetAccess() + " success to execute command " + command + " from ip: " + GetIP( player.GetIp() ) );
            return true;
        }
        break;
    // ACCESS_MODER
    case COMMAND_ADDITEM:
    case COMMAND_ADDITEM_SELF:
    case COMMAND_ADDLOCATION:
    case COMMAND_ADDNPC:
    case COMMAND_BAN:
    case COMMAND_CHECKVAR:
    case COMMAND_CRITID:
    case COMMAND_DISCONCRIT:
    case COMMAND_GAMEINFO:
    case COMMAND_KILLCRIT:
    case COMMAND_MOVECRIT:
    case COMMAND_RESPAWN:
    case COMMAND_SETVAR:
        if( player.GetAccess() >= ACCESS_MODER )
        {
            FLog( LOG_GM, player.Name + " (" + player.Id + ") with access level " + player.GetAccess() + " success to execute command " + command + " from ip: " + GetIP( player.GetIp() ) );
            return true;
        }
        break;
    // ACCESS_ADMIN
    case COMMAND_LOADDIALOG:
    case COMMAND_LOADLOCATION:
    case COMMAND_LOADMAP:
    case COMMAND_LOADSCRIPT:
    case COMMAND_LOG:
    case COMMAND_RELOAD_CLIENT_SCRIPTS:
    case COMMAND_RELOADAI:
    case COMMAND_RELOADDIALOGS:
    case COMMAND_RELOADLOCATIONS:
    case COMMAND_RELOADMAPS:
    case COMMAND_RELOADSCRIPTS:
    case COMMAND_RELOADTEXTS:
    case COMMAND_REGENMAP:
    case COMMAND_RUNSCRIPT:
    case COMMAND_SETTIME:
        if( player.GetAccess() == ACCESS_ADMIN )
        {
            FLog( LOG_GM, player.Name + " (" + player.Id + ") with access level " + player.GetAccess() + " success to execute command " + command + " from ip: " + GetIP( player.GetIp() ) );
            return true;
        }
        break;
    // Unknown command
    default:
        player.Say( SAY_NETMSG, "Unknown command." );
        return false;
    }

    if( valid( player ) )
        FLog( LOG_GM, player.Name + " (" + player.Id + ") with access level " + player.GetAccess() + " failed execute command " + command + " from ip: " + GetIP( player.GetIp() ) );
    player.Say( SAY_NETMSG, "Access denied." );
    return false;
}

void unsafe_clientlooged( Critter& player, int, int, int, string@, int[] @ )
{
// if (valid(player))
    // shownews( player );
}

uint e_DelayedSendFD( uint[] @ values )
{
    Critter@ cr = GetCritter( values[ 0 ] );
    if( valid( cr ) )
        SendFactionData( cr, 0 );
    return 0;
}

uint e_DelayedSendRD( uint[] @ values )
{
    Critter@ cr = GetCritter( values[ 0 ] );
    if( valid( cr ) )
        SendRelationsData( cr );
    return 0;
}

uint e_DelayedSendScore( uint[] @ values )
{
    Critter@ cr = GetCritter( values[ 0 ] );
    if( valid( cr ) )
        SendFactionScore( cr );
    return 0;
}

uint e_SendScore( uint[] @ values )
{
    SendFactionScore( null );
    return REAL_MINUTE( 15 );
}

uint e_DelayedSMToClient( uint[] @ values )
{
    Critter@ cr = GetCritter( values[ 0 ] );
    if( valid( cr ) && cr.IsPlayer() )
    {
        SendMessagesToClients( cr );
        FLog( LOG_LOGIN, "Logged in player: " + cr.Name + " (" + cr.Id + ") uids:" + cr.GetUID( 0 ) + " " + cr.GetUID( 1 ) + " " + cr.GetUID( 2 ) + " " + cr.GetUID( 3 ) + " " + cr.GetUID( 4 ) );
    }
    return 0;
}

void CrSpeedCalc( Critter& cr )
{
    if( !valid( cr ) )
        return;

    int speedmod = 0;
    if( cr.Skill[ SK_SMALL_GUNS ] < 111 && cr.Skill[ SK_BIG_GUNS ] < 101 && cr.Skill[ SK_ENERGY_WEAPONS ] < 101 )
    {
        speedmod = GetSpeedMod( cr, SLOT_HAND1 );
        if( speedmod > 0 )
        {
            speedmod = GetSpeedMod( cr, SLOT_HAND2 );
        }
    }
    speedmod += cr.Perk[ PE_IMPLANT_SPEED ] > 0 ? 20 : 0;
    cr.ParamBase[ ST_RUN_TIME ] = 200 - speedmod;
}

int GetSpeedMod( Critter& cr, uint8 Slot )
{
    uint8      mode = 0;
    ProtoItem@ item = cr.GetSlotProto( Slot, mode );
    if( valid( item ) && item.Type == ITEM_TYPE_WEAPON )
    {
        // if (item.ProtoId==PID_AVENGER_MINIGUN)
        //	return -16;
        uint skillNum = _WeaponSkill( item, 0 );
        if( cr.Skill[ SK_UNARMED ] > 103 && ( skillNum == SK_UNARMED || skillNum == SK_THROWING ) )
            return ( cr.Skill[ SK_UNARMED ] >= 200 ? 200 : cr.Skill[ SK_UNARMED ] ) / 4;

    }
    else if( cr.Skill[ SK_UNARMED ] > 103 )
        return ( cr.Skill[ SK_UNARMED ] >= 200 ? 200 : cr.Skill[ SK_UNARMED ] ) / 4;
    return 0;
}

array< uint > Prisoners;

void CheckBan( Critter& cr )
{
    Map@ map = cr.GetMap();
    if( valid( map ) && IsPrison( map ) )
        return;

    if( Prisoners.find( cr.Id ) < 0 )
        return;
    Map@ jailmap = GetMapByPid( 442, 0 );
    if( valid( jailmap ) )
        cr.TransitToMap( jailmap.Id, 0 );
}

void LoadPrisoners()
{
    file f;
    if( f.open( "data/bans.txt", "r" ) == 0 )
    {
        string line;
        string@[] lines;
        while( f.readLine( line ) > 0 )
        {
            lines = split( line, ";" );
        }
        f.close();
        for( uint i = 0; i < lines.length(); i++ )
        {
            int id = 0;
            if( StrToInt( lines[ i ], id ) )
            {
                Prisoners.insertLast( id );
                Log( "Loaded " + id );
            }
        }
    }
}

void ReloadPrisoners( Critter& cr, int, int, int )
{
    Prisoners.resize( 0 );
    LoadPrisoners();
}

void Patch( Critter& cr )
{
    if( cr.Param[ PATCH1 ] == 0 )
    {
        Patch1( cr );
        // Patch2(cr);
        // Patch3(cr);
    }
    /*
        else if (cr.Param[PATCH1]==1)
        {
                Patch2(cr);
                Patch3(cr);
        }
        else if (cr.Param[PATCH1]==2)
                Patch3(cr);
     */
    else
        return;
    cr.ParamBase[ PATCH1 ] = 1;
}

void Patch1( Critter& cr )
{
    if( cr.Param[ PE_BONUS_HTH_DAMAGE ] > 0 )
    {
        int dmg = cr.ParamBase[ ST_MELEE_DAMAGE ] - ( 4 * cr.Param[ PE_BONUS_HTH_DAMAGE ] );
        cr.ParamBase[ PE_BONUS_HTH_DAMAGE ] = 0;
        cr.ParamBase[ ST_MELEE_DAMAGE ] = dmg;
    }
    if( cr.Param[ TRAIT_BRUISER ] > 0 )
    {
        cr.ParamBase[ ST_ACTION_POINTS ] += 2;
    }
    cr.ParamBase[ FREE_REROLL ] = 1;
}


